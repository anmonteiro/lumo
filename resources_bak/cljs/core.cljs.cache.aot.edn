{:rename-macros {}, :renames {}, :use-macros {}, :excludes #{}, :name cljs.core, :imports {StringBuffer goog.string.StringBuffer}, :requires {goog.math.Long goog.math.Long, goog.math.Integer goog.math.Integer, gstring goog.string, goog.string goog.string, gobject goog.object, goog.object goog.object, garray goog.array, goog.array goog.array, StringBuffer goog.string.StringBuffer}, :uses nil, :defs {->PersistentHashSet {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8362, :column 10, :end-line 8362, :end-column 27, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta hash-map __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentHashSet, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([meta hash-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8362, :end-line 8362, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta hash-map __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, js->clj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9744, :column 7, :end-line 9744, :end-column 14, :arglists (quote ([x] [x & opts])), :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([x]), :arglists ([x] [x & opts]), :arglists-meta (nil nil)}}, :name cljs.core/js->clj, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([x]), :arglists ([x] [x & opts]), :arglists-meta (nil nil)}, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9744, :end-line 9744, :max-fixed-arity 1, :fn-var true, :arglists ([x] [x & opts]), :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords."}, sort-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2319, :column 7, :end-line 2319, :end-column 14, :arglists (quote ([keyfn coll] [keyfn comp coll])), :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([keyfn coll] [keyfn comp coll]), :arglists ([keyfn coll] [keyfn comp coll]), :arglists-meta (nil nil)}}, :name cljs.core/sort-by, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([keyfn coll] [keyfn comp coll]), :arglists ([keyfn coll] [keyfn comp coll]), :arglists-meta (nil nil)}, :method-params ([keyfn coll] [keyfn comp coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2319, :end-line 2319, :max-fixed-arity 3, :fn-var true, :arglists ([keyfn coll] [keyfn comp coll]), :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare."}, ITransientAssociative {:meta {:file "cljs/core.cljs", :line 695, :column 14, :end-line 695, :end-column 35, :doc "Protocol for adding associativity to transient collections.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-assoc! [[tcoll key val]]}}}, :protocol-symbol true, :name cljs.core/ITransientAssociative, :file "cljs/core.cljs", :end-column 35, :column 1, :line 695, :protocol-info {:methods {-assoc! [[tcoll key val]]}}, :info nil, :end-line 695, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :doc "Protocol for adding associativity to transient collections.", :jsdoc ("@interface")}, chunk-first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3458, :column 7, :end-line 3458, :end-column 18, :arglists (quote ([s]))}, :name cljs.core/chunk-first, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3458, :end-line 3458, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, print-meta? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9193, :column 16, :end-line 9193, :end-column 27, :tag boolean, :arglists (quote ([opts obj]))}, :name cljs.core/print-meta?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([opts obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9193, :ret-tag boolean, :end-line 9193, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([opts obj]))}, m3-hash-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 831, :column 15, :end-line 831, :end-column 26, :tag number, :arglists (quote ([in]))}, :name cljs.core/m3-hash-int, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 831, :ret-tag number, :end-line 831, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in]))}, stepper {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3866, :column 7, :end-line 3866, :end-column 14, :arglists (quote ([xform iter]))}, :name cljs.core/stepper, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([xform iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3866, :end-line 3866, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform iter]))}, pr-str* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 779, :column 7, :end-line 779, :end-column 14, :arglists (quote ([obj])), :doc "Support so that collections can implement toString without\n   loading all the printing machinery."}, :name cljs.core/pr-str*, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 779, :end-line 779, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Support so that collections can implement toString without\n   loading all the printing machinery."}, eduction {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9687, :column 7, :end-line 9687, :end-column 15, :arglists (quote ([xform* coll])), :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xforms)], :arglists ([& xforms]), :arglists-meta (nil)}}, :name cljs.core/eduction, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xforms)], :arglists ([& xforms]), :arglists-meta (nil)}, :method-params [(xforms)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9687, :end-line 9687, :max-fixed-arity 0, :fn-var true, :arglists ([& xforms]), :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called."}, tree-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4741, :column 7, :end-line 4741, :end-column 15, :arglists (quote ([branch? children root])), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree."}, :name cljs.core/tree-seq, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([branch? children root]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4741, :end-line 4741, :max-fixed-arity 3, :fn-var true, :arglists (quote ([branch? children root])), :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree."}, unchecked-remainder-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2617, :column 7, :end-line 2617, :end-column 30, :arglists (quote ([x n]))}, :name cljs.core/unchecked-remainder-int, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2617, :end-line 2617, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n]))}, uuid {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10270, :column 7, :end-line 10270, :end-column 11, :arglists (quote ([s]))}, :name cljs.core/uuid, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10270, :end-line 10270, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1104, :column 12, :end-line 1104, :end-column 15, :tag seq, :arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings."}, :name cljs.core/seq, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1104, :ret-tag seq, :end-line 1104, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings."}, Volatile {:num-fields 1, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/Volatile, :file "cljs/core.cljs", :end-column 18, :type true, :column 10, :line 4337, :record false, :end-line 4337, :skip-protocol-flag #{cljs.core/IDeref}}, reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2353, :column 7, :end-line 2353, :end-column 13, :arglists (quote ([f coll] [f val coll])), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}}, :name cljs.core/reduce, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}, :method-params ([f coll] [f val coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2353, :end-line 2353, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f val coll]), :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called."}, IUUID {:meta {:file "cljs/core.cljs", :line 10242, :column 14, :end-line 10242, :end-column 19, :doc "A marker protocol for UUIDs", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/IUUID, :file "cljs/core.cljs", :end-column 19, :column 1, :line 10242, :protocol-info {:methods {}}, :info nil, :end-line 10242, :impls #{cljs.core/UUID}, :doc "A marker protocol for UUIDs", :jsdoc ("@interface")}, INIT {:name cljs.core/INIT, :file "cljs/core.cljs", :line 3815, :column 1, :end-line 3815, :end-column 10, :meta {:file "cljs/core.cljs", :line 3815, :column 6, :end-line 3815, :end-column 10}}, find-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10598, :column 7, :end-line 10598, :end-column 14, :arglists (quote ([ns])), :doc "Bootstrap only."}, :name cljs.core/find-ns, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10598, :end-line 10598, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns])), :doc "Bootstrap only."}, contains? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2210, :column 16, :end-line 2210, :end-column 25, :tag boolean, :arglists (quote ([coll v])), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'."}, :name cljs.core/contains?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2210, :ret-tag boolean, :end-line 2210, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll v])), :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'."}, every? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4030, :column 16, :end-line 4030, :end-column 22, :tag boolean, :arglists (quote ([pred coll])), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false."}, :name cljs.core/every?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4030, :ret-tag boolean, :end-line 4030, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false."}, ->ES6IteratorSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1195, :column 10, :end-line 1195, :end-column 24, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}, :factory :positional, :arglists (quote ([value iter _rest]))}, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/->ES6IteratorSeq, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([value iter _rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1195, :end-line 1195, :max-fixed-arity 3, :fn-var true, :arglists (quote ([value iter _rest])), :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}}, Var {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/IMeta cljs.core/Fn cljs.core/IDeref cljs.core/IWithMeta}, :name cljs.core/Var, :file "cljs/core.cljs", :end-column 13, :type true, :column 10, :line 1012, :record false, :end-line 1012, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/IMeta cljs.core/IDeref cljs.core/IWithMeta}}, keep-indexed {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4359, :column 7, :end-line 4359, :end-column 19, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/keep-indexed, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4359, :end-line 4359, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided."}, ->PersistentQueueSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5680, :column 10, :end-line 5680, :end-column 28, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta front rear __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueueSeq, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([meta front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5680, :end-line 5680, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, subs {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2813, :column 7, :end-line 2813, :end-column 11, :arglists (quote ([s start] [s start end])), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s start] [s start end]), :arglists ([s start] [s start end]), :arglists-meta (nil nil)}}, :name cljs.core/subs, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s start] [s start end]), :arglists ([s start] [s start end]), :arglists-meta (nil nil)}, :method-params ([s start] [s start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2813, :end-line 2813, :max-fixed-arity 3, :fn-var true, :arglists ([s start] [s start end]), :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive."}, set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8597, :column 7, :end-line 8597, :end-column 10, :arglists (quote ([coll])), :doc "Returns a set of the distinct elements of coll."}, :name cljs.core/set, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8597, :end-line 8597, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a set of the distinct elements of coll."}, compare-indexed {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2273, :column 17, :end-line 2273, :end-column 32, :private true, :arglists (quote ([xs ys] [xs ys len n])), :doc "Compare indexed collection.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xs ys] [xs ys len n]), :arglists ([xs ys] [xs ys len n]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/compare-indexed, :variadic false, :file "cljs/core.cljs", :end-column 32, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xs ys] [xs ys len n]), :arglists ([xs ys] [xs ys len n]), :arglists-meta (nil nil)}, :method-params ([xs ys] [xs ys len n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2273, :end-line 2273, :max-fixed-arity 4, :fn-var true, :arglists ([xs ys] [xs ys len n]), :doc "Compare indexed collection."}, take-last {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4577, :column 7, :end-line 4577, :end-column 16, :arglists (quote ([n coll])), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec."}, :name cljs.core/take-last, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4577, :end-line 4577, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec."}, IndexedSeq {:meta {:file "cljs/core.cljs", :line 1087, :column 29, :end-line 1087, :end-column 39, :declared true}, :num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/IndexedSeq, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 1470, :record false, :declared true, :end-line 1470, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, bit-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2728, :column 7, :end-line 2728, :end-column 14, :arglists (quote ([x n])), :doc "Set bit at index n"}, :name cljs.core/bit-set, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2728, :end-line 2728, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Set bit at index n"}, string-hash-cache-count {:name cljs.core/string-hash-cache-count, :file "cljs/core.cljs", :line 858, :column 1, :end-line 858, :end-column 29, :meta {:file "cljs/core.cljs", :line 858, :column 6, :end-line 858, :end-column 29}}, qualified-keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3218, :column 16, :end-line 3218, :end-column 34, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a keyword with a namespace"}, :name cljs.core/qualified-keyword?, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3218, :ret-tag boolean, :end-line 3218, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a keyword with a namespace"}, ->Eduction {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9661, :column 10, :end-line 9661, :end-column 18, :protocols #{cljs.core/Object cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :factory :positional, :arglists (quote ([xform coll]))}, :protocols #{cljs.core/Object cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/->Eduction, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([xform coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 9661, :end-line 9661, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform coll])), :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}}, tree-map-add {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7851, :column 8, :end-line 7851, :end-column 20, :private true, :arglists (quote ([comp tree k v found]))}, :private true, :name cljs.core/tree-map-add, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([comp tree k v found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7851, :end-line 7851, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree k v found]))}, ->ES6SetEntriesIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6003, :column 10, :end-line 6003, :end-column 31, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6SetEntriesIterator, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6003, :end-line 6003, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil}, -with-meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 588, :column 9, :end-line 588, :end-column 19, :tag clj, :protocol cljs.core/IWithMeta, :doc "Returns a new object with value of o and metadata meta added to it.", :arglists (quote ([o meta]))}, :protocol cljs.core/IWithMeta, :name cljs.core/-with-meta, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 586, :ret-tag clj, :end-line 588, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([o meta])), :doc "Returns a new object with value of o and metadata meta added to it."}, reset-cache {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9951, :column 8, :end-line 9951, :end-column 19, :private true, :arglists (quote ([method-cache method-table cached-hierarchy hierarchy]))}, :private true, :name cljs.core/reset-cache, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([method-cache method-table cached-hierarchy hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9951, :end-line 9951, :max-fixed-arity 4, :fn-var true, :arglists (quote ([method-cache method-table cached-hierarchy hierarchy]))}, ->PersistentArrayMapIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6163, :column 10, :end-line 6163, :end-column 36, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i cnt]))}, :protocols #{cljs.core/Object}, :name cljs.core/->PersistentArrayMapIterator, :variadic false, :file "cljs/core.cljs", :end-column 36, :method-params ([arr i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6163, :end-line 6163, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i cnt])), :skip-protocol-flag nil}, PersistentArrayMapIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/PersistentArrayMapIterator, :file "cljs/core.cljs", :end-column 36, :type true, :column 10, :line 6163, :record false, :end-line 6163, :skip-protocol-flag nil}, butlast {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8675, :column 7, :end-line 8675, :end-column 14, :arglists (quote ([s])), :doc "Return a seq of all but the last item in coll, in linear time"}, :name cljs.core/butlast, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8675, :end-line 8675, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return a seq of all but the last item in coll, in linear time"}, tail-off {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4914, :column 8, :end-line 4914, :end-column 16, :private true, :arglists (quote ([pv]))}, :private true, :name cljs.core/tail-off, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4914, :end-line 4914, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv]))}, unchecked-subtract-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2627, :column 15, :end-line 2627, :end-column 37, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/unchecked-subtract-int, :variadic true, :file "cljs/core.cljs", :end-column 37, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2627, :ret-tag number, :end-line 2627, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, -iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 769, :column 4, :end-line 769, :end-column 13, :protocol cljs.core/IIterable, :doc "Returns an iterator for coll.", :arglists (quote ([coll]))}, :protocol cljs.core/IIterable, :name cljs.core/-iterator, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 767, :end-line 769, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an iterator for coll."}, take-nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8932, :column 7, :end-line 8932, :end-column 15, :arglists (quote ([n] [n coll])), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/take-nth, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8932, :end-line 8932, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided."}, first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1127, :column 7, :end-line 1127, :end-column 12, :arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil."}, :name cljs.core/first, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1127, :end-line 1127, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil."}, native-satisfies? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 241, :column 16, :end-line 241, :end-column 33, :tag boolean, :arglists (quote ([p x])), :doc "Internal - do not use!"}, :name cljs.core/native-satisfies?, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([p x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 241, :ret-tag boolean, :end-line 241, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([p x])), :doc "Internal - do not use!"}, seq? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2108, :column 16, :end-line 2108, :end-column 20, :tag boolean, :arglists (quote ([s])), :doc "Return true if s satisfies ISeq"}, :name cljs.core/seq?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2108, :ret-tag boolean, :end-line 2108, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeq"}, -global-hierarchy {:name cljs.core/-global-hierarchy, :file "cljs/core.cljs", :line 9838, :column 1, :end-line 9841, :end-column 20, :private true, :jsdoc ["@type {*}"], :meta {:file "cljs/core.cljs", :line 9841, :column 3, :end-line 9841, :end-column 20, :private true, :jsdoc ["@type {*}"]}}, UUID {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable cljs.core/IUUID}, :name cljs.core/UUID, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 10244, :record false, :end-line 10244, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}}, -sorted-seq-from {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 640, :column 9, :end-line 640, :end-column 25, :tag clj, :protocol cljs.core/ISorted, :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :arglists (quote ([coll k ascending?]))}, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq-from, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([coll k ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 635, :ret-tag clj, :end-line 640, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k ascending?])), :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)"}, println-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9362, :column 7, :end-line 9362, :end-column 18, :arglists (quote ([& objs])), :doc "println to a string, returning it", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/println-str, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9362, :end-line 9362, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "println to a string, returning it"}, inst-ms {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1286, :column 7, :end-line 1286, :end-column 14, :arglists (quote ([inst])), :doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT"}, :name cljs.core/inst-ms, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([inst]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1286, :end-line 1286, :max-fixed-arity 1, :fn-var true, :arglists (quote ([inst])), :doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT"}, linear-traversal-nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1722, :column 8, :end-line 1722, :end-column 28, :private true, :arglists (quote ([coll n] [coll n not-found])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/linear-traversal-nth, :variadic false, :file "cljs/core.cljs", :end-column 28, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1722, :end-line 1722, :max-fixed-arity 3, :fn-var true, :arglists ([coll n] [coll n not-found])}, iterate {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4639, :column 7, :end-line 4639, :end-column 14, :arglists (quote ([f x])), :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :added "1.0"}, :added "1.0", :name cljs.core/iterate, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([f x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4639, :end-line 4639, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f x])), :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"}, -empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 483, :column 4, :end-line 483, :end-column 10, :protocol cljs.core/IEmptyableCollection, :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.", :arglists (quote ([coll]))}, :protocol cljs.core/IEmptyableCollection, :name cljs.core/-empty, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 481, :end-line 483, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty."}, ->t_cljs$core9610 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta9611])), :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t_cljs$core9610, :variadic false, :file "cljs/core.cljs", :method-params ([meta9611]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :line 3785, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta9611])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, newline {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9317, :column 7, :end-line 9317, :end-column 14, :arglists (quote ([] [opts])), :doc "Prints a newline using *print-fn*", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [opts]), :arglists ([] [opts]), :arglists-meta (nil nil)}}, :name cljs.core/newline, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [opts]), :arglists ([] [opts]), :arglists-meta (nil nil)}, :method-params ([] [opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9317, :end-line 9317, :max-fixed-arity 1, :fn-var true, :arglists ([] [opts]), :doc "Prints a newline using *print-fn*"}, ILookup {:meta {:file "cljs/core.cljs", :line 525, :column 14, :end-line 525, :end-column 21, :doc "Protocol for looking up a value in a data structure.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-lookup [[o k] [o k not-found]]}}}, :protocol-symbol true, :name cljs.core/ILookup, :file "cljs/core.cljs", :end-column 21, :column 1, :line 525, :protocol-info {:methods {-lookup [[o k] [o k not-found]]}}, :info nil, :end-line 525, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/Subvec cljs.core/TransientHashMap cljs.core/TaggedLiteral cljs.core/PersistentVector cljs.core/TransientArrayMap cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/RedNode}, :doc "Protocol for looking up a value in a data structure.", :jsdoc ("@interface")}, -chunked-rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 733, :column 4, :end-line 733, :end-column 17, :protocol cljs.core/IChunkedSeq, :doc "Return a new collection of coll with the first chunk removed.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-rest, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 729, :end-line 733, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a new collection of coll with the first chunk removed."}, write-all {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9163, :column 7, :end-line 9163, :end-column 16, :arglists (quote ([writer & ss])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(writer ss)], :arglists ([writer & ss]), :arglists-meta (nil)}}, :name cljs.core/write-all, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(writer ss)], :arglists ([writer & ss]), :arglists-meta (nil)}, :method-params [(writer ss)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9163, :end-line 9163, :max-fixed-arity 1, :fn-var true, :arglists ([writer & ss])}, fn? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1889, :column 16, :end-line 1889, :end-column 19, :tag boolean, :arglists (quote ([f])), :doc "Return true if f is a JavaScript function or satisfies the Fn protocol."}, :name cljs.core/fn?, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1889, :ret-tag boolean, :end-line 1889, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Return true if f is a JavaScript function or satisfies the Fn protocol."}, -prefer-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10007, :column 4, :end-line 10007, :end-column 18, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val dispatch-val-y]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-prefer-method, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([mf dispatch-val dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10003, :end-line 10007, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val dispatch-val-y])), :doc nil}, -assoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 536, :column 9, :end-line 536, :end-column 15, :tag clj, :protocol cljs.core/IAssociative, :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :arglists (quote ([coll k v]))}, :protocol cljs.core/IAssociative, :name cljs.core/-assoc, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 531, :ret-tag clj, :end-line 536, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll k v])), :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it."}, doall {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9073, :column 7, :end-line 9073, :end-column 12, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/doall, :variadic false, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}, :method-params ([coll] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9073, :end-line 9073, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [n coll]), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time."}, keyword-identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3169, :column 16, :end-line 3169, :end-column 34, :tag boolean, :arglists (quote ([x y])), :doc "Efficient test to determine that two keywords are identical."}, :name cljs.core/keyword-identical?, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3169, :ret-tag boolean, :end-line 3169, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Efficient test to determine that two keywords are identical."}, *print-err-fn* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 59, :column 3, :end-line 59, :end-column 17, :doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed.", :dynamic true}, :name cljs.core/*print-err-fn*, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([_]), :protocol-impl nil, :arglists-meta (), :column 1, :dynamic true, :line 55, :end-line 59, :max-fixed-arity 1, :fn-var true, :arglists nil, :doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed."}, pv-aset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4908, :column 8, :end-line 4908, :end-column 15, :private true, :arglists (quote ([node idx val]))}, :private true, :name cljs.core/pv-aset, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([node idx val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4908, :end-line 4908, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node idx val]))}, prefers {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10229, :column 7, :end-line 10229, :end-column 14, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of preferred value -> set of other values"}, :name cljs.core/prefers, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10229, :end-line 10229, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of preferred value -> set of other values"}, -js->clj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9742, :column 4, :end-line 9742, :end-column 12, :protocol cljs.core/IEncodeClojure, :doc "Transforms JavaScript values to Clojure", :arglists (quote ([x options]))}, :protocol cljs.core/IEncodeClojure, :name cljs.core/-js->clj, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x options]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9741, :end-line 9742, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x options])), :doc "Transforms JavaScript values to Clojure"}, LazySeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/LazySeq, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 3246, :record false, :end-line 3246, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, t_cljs$core9607 {:num-fields 1, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t_cljs$core9607, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3785, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, dedupe {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9634, :column 7, :end-line 9634, :end-column 13, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}}, :name cljs.core/dedupe, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9634, :end-line 9634, :max-fixed-arity 1, :fn-var true, :arglists ([] [coll]), :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided."}, unchecked-editable-array-for {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5516, :column 8, :end-line 5516, :end-column 36, :private true, :arglists (quote ([tv i]))}, :private true, :name cljs.core/unchecked-editable-array-for, :variadic false, :file "cljs/core.cljs", :end-column 36, :method-params ([tv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5516, :end-line 5516, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tv i]))}, ->ES6Iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1179, :column 10, :end-line 1179, :end-column 21, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6Iterator, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1179, :end-line 1179, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil}, VectorNode {:num-fields 2, :protocols #{}, :name cljs.core/VectorNode, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 4900, :record false, :end-line 4900, :skip-protocol-flag nil}, dissoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1875, :column 7, :end-line 1875, :end-column 13, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}}, :name cljs.core/dissoc, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}, :method-params ([coll] [coll k]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1875, :end-line 1875, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [coll k] [coll k & ks]), :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s)."}, atom {:name cljs.core/atom, :file "cljs/core.cljs", :line 6438, :column 1, :end-line 6438, :end-column 72, :declared true, :meta {:file "cljs/core.cljs", :line 6438, :column 68, :end-line 6438, :end-column 72, :declared true}}, bit-shift-right {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2742, :column 7, :end-line 2742, :end-column 22, :arglists (quote ([x n])), :doc "Bitwise shift right"}, :name cljs.core/bit-shift-right, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2742, :end-line 2742, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right"}, *clojurescript-version* {:name cljs.core/*clojurescript-version*, :file "cljs/core.cljs", :line 18, :column 1, :end-line 18, :end-column 29, :meta {:file "cljs/core.cljs", :line 18, :column 6, :end-line 18, :end-column 29}}, -first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 509, :column 4, :end-line 509, :end-column 10, :protocol cljs.core/ISeq, :doc "Returns the first item in the collection coll. Used by cljs.core/first.", :arglists (quote ([coll]))}, :protocol cljs.core/ISeq, :name cljs.core/-first, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 507, :end-line 509, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first item in the collection coll. Used by cljs.core/first."}, peek {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1963, :column 7, :end-line 1963, :end-column 11, :arglists (quote ([coll])), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil."}, :name cljs.core/peek, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1963, :end-line 1963, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil."}, IKVReduce {:meta {:file "cljs/core.cljs", :line 599, :column 14, :end-line 599, :end-column 23, :doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-kv-reduce [[coll f init]]}}}, :protocol-symbol true, :name cljs.core/IKVReduce, :file "cljs/core.cljs", :end-column 23, :column 1, :line 599, :protocol-info {:methods {-kv-reduce [[coll f init]]}}, :info nil, :end-line 599, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap}, :doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.", :jsdoc ("@interface")}, aget {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 403, :column 7, :end-line 403, :end-column 11, :arglists (quote ([array i] [array i & idxs])), :doc "Returns the value at the index.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([array i]), :arglists ([array i] [array i & idxs]), :arglists-meta (nil nil)}}, :name cljs.core/aget, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([array i]), :arglists ([array i] [array i & idxs]), :arglists-meta (nil nil)}, :method-params ([array i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 403, :end-line 403, :max-fixed-arity 2, :fn-var true, :arglists ([array i] [array i & idxs]), :doc "Returns the value at the index."}, PersistentTreeMapSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentTreeMapSeq, :file "cljs/core.cljs", :end-column 30, :type true, :column 10, :line 7419, :record false, :end-line 7419, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -write {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 654, :column 4, :end-line 654, :end-column 10, :protocol cljs.core/IWriter, :doc "Writes s with writer and returns the result.", :arglists (quote ([writer s]))}, :protocol cljs.core/IWriter, :name cljs.core/-write, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([writer s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 652, :end-line 654, :max-fixed-arity 2, :fn-var true, :arglists (quote ([writer s])), :doc "Writes s with writer and returns the result."}, iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3839, :column 7, :end-line 3839, :end-column 11, :arglists (quote ([coll]))}, :name cljs.core/iter, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3839, :end-line 3839, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, mk-bound-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8779, :column 7, :end-line 8779, :end-column 18, :arglists (quote ([sc test key]))}, :name cljs.core/mk-bound-fn, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([sc test key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8779, :end-line 8779, :max-fixed-arity 3, :fn-var true, :arglists (quote ([sc test key]))}, last {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1662, :column 7, :end-line 1662, :end-column 11, :arglists (quote ([s])), :doc "Return the last item in coll, in linear time"}, :name cljs.core/last, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1662, :end-line 1662, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Return the last item in coll, in linear time"}, -default-dispatch-val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10011, :column 4, :end-line 10011, :end-column 25, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-default-dispatch-val, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10003, :end-line 10011, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, pr {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9335, :column 7, :end-line 9335, :end-column 9, :arglists (quote ([& objs])), :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/pr, :variadic true, :file "cljs/core.cljs", :end-column 9, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9335, :end-line 9335, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader"}, tree-map-seq-push {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7412, :column 8, :end-line 7412, :end-column 25, :private true, :arglists (quote ([node stack ascending?]))}, :private true, :name cljs.core/tree-map-seq-push, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([node stack ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7412, :end-line 7412, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node stack ascending?]))}, namespace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3187, :column 7, :end-line 3187, :end-column 16, :arglists (quote ([x])), :doc "Returns the namespace String of a symbol or keyword, or nil if not present."}, :name cljs.core/namespace, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3187, :end-line 3187, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the namespace String of a symbol or keyword, or nil if not present."}, empty-unordered-hash {:name cljs.core/empty-unordered-hash, :file "cljs/core.cljs", :line 1253, :column 1, :end-line 1253, :end-column 36, :private true, :meta {:file "cljs/core.cljs", :line 1253, :column 16, :end-line 1253, :end-column 36, :private true}}, obj-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8126, :column 7, :end-line 8126, :end-column 14, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new object map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/obj-map, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8126, :end-line 8126, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new object map with supplied mappings."}, Reduced {:num-fields 1, :protocols #{cljs.core/IDeref}, :name cljs.core/Reduced, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 1319, :record false, :end-line 1319, :skip-protocol-flag #{cljs.core/IDeref}}, -conj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 489, :column 9, :end-line 489, :end-column 14, :tag clj, :protocol cljs.core/ICollection, :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :arglists (quote ([coll o]))}, :protocol cljs.core/ICollection, :name cljs.core/-conj, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 487, :ret-tag clj, :end-line 489, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll o])), :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)"}, NodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/NodeSeq, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 7002, :record false, :end-line 7002, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, = {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1160, :column 16, :end-line 1160, :end-column 17, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/=, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1160, :ret-tag boolean, :end-line 1160, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison."}, ITransientMap {:meta {:file "cljs/core.cljs", :line 701, :column 14, :end-line 701, :end-column 27, :doc "Protocol for adding mapping functionality to transient collections.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-dissoc! [[tcoll key]]}}}, :protocol-symbol true, :name cljs.core/ITransientMap, :file "cljs/core.cljs", :end-column 27, :column 1, :line 701, :protocol-info {:methods {-dissoc! [[tcoll key]]}}, :info nil, :end-line 701, :impls #{cljs.core/TransientHashMap cljs.core/TransientArrayMap}, :doc "Protocol for adding mapping functionality to transient collections.", :jsdoc ("@interface")}, push-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4930, :column 8, :end-line 4930, :end-column 17, :private true, :arglists (quote ([pv level parent tailnode]))}, :private true, :name cljs.core/push-tail, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pv level parent tailnode]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4930, :end-line 4930, :max-fixed-arity 4, :fn-var true, :arglists (quote ([pv level parent tailnode]))}, take {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4520, :column 7, :end-line 4520, :end-column 11, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/take, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4520, :end-line 4520, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided."}, vector? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2040, :column 16, :end-line 2040, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies IVector"}, :name cljs.core/vector?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2040, :ret-tag boolean, :end-line 2040, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IVector"}, array-index-of-equiv? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6053, :column 8, :end-line 6053, :end-column 29, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-equiv?, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6053, :end-line 6053, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, bitmap-indexed-node-index {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6464, :column 8, :end-line 6464, :end-column 33, :private true, :arglists (quote ([bitmap bit]))}, :private true, :name cljs.core/bitmap-indexed-node-index, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([bitmap bit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6464, :end-line 6464, :max-fixed-arity 2, :fn-var true, :arglists (quote ([bitmap bit]))}, boolean {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2120, :column 16, :end-line 2120, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Coerce to boolean"}, :name cljs.core/boolean, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2120, :ret-tag boolean, :end-line 2120, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Coerce to boolean"}, IChunk {:meta {:file "cljs/core.cljs", :line 724, :column 14, :end-line 724, :end-column 20, :doc "Protocol for accessing the items of a chunk.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-drop-first [[coll]]}}}, :protocol-symbol true, :name cljs.core/IChunk, :file "cljs/core.cljs", :end-column 20, :column 1, :line 724, :protocol-info {:methods {-drop-first [[coll]]}}, :info nil, :end-line 724, :impls #{cljs.core/ArrayChunk}, :doc "Protocol for accessing the items of a chunk.", :jsdoc ("@interface")}, bit-shift-left {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2738, :column 7, :end-line 2738, :end-column 21, :arglists (quote ([x n])), :doc "Bitwise shift left"}, :name cljs.core/bit-shift-left, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2738, :end-line 2738, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift left"}, random-uuid {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10273, :column 7, :end-line 10273, :end-column 18, :arglists (quote ([]))}, :name cljs.core/random-uuid, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10273, :end-line 10273, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, any? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 236, :column 16, :end-line 236, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if given any argument."}, :name cljs.core/any?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 236, :ret-tag boolean, :end-line 236, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if given any argument."}, rand-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9811, :column 7, :end-line 9811, :end-column 15, :arglists (quote ([n])), :doc "Returns a random integer between 0 (inclusive) and n (exclusive)."}, :name cljs.core/rand-int, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9811, :end-line 9811, :max-fixed-arity 1, :fn-var true, :arglists (quote ([n])), :doc "Returns a random integer between 0 (inclusive) and n (exclusive)."}, aclone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 382, :column 7, :end-line 382, :end-column 13, :arglists (quote ([arr])), :doc "Returns a javascript array, cloned from the passed in array"}, :name cljs.core/aclone, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 382, :end-line 382, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :doc "Returns a javascript array, cloned from the passed in array"}, BlackNode {:meta {:file "cljs/core.cljs", :line 7483, :column 18, :end-line 7483, :end-column 27, :declared true}, :num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/BlackNode, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 7586, :record false, :declared true, :end-line 7586, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, vreset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4354, :column 7, :end-line 4354, :end-column 14, :arglists (quote ([vol newval])), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval."}, :name cljs.core/vreset!, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([vol newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4354, :end-line 4354, :max-fixed-arity 2, :fn-var true, :arglists (quote ([vol newval])), :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval."}, chunk {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3455, :column 7, :end-line 3455, :end-column 12, :arglists (quote ([b]))}, :name cljs.core/chunk, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3455, :end-line 3455, :max-fixed-arity 1, :fn-var true, :arglists (quote ([b]))}, dec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2520, :column 7, :end-line 2520, :end-column 10, :arglists (quote ([x])), :doc "Returns a number one less than num."}, :name cljs.core/dec, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2520, :end-line 2520, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than num."}, map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4473, :column 7, :end-line 4473, :end-column 10, :arglists (quote ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/map, :variadic true, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil nil)}, :method-params ([f] [f coll] [f c1 c2] [f c1 c2 c3]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 4473, :end-line 4473, :max-fixed-arity 4, :fn-var true, :arglists ([f] [f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided."}, juxt {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9024, :column 7, :end-line 9024, :end-column 11, :arglists (quote ([f] [f g] [f g h] [f g h & fs])), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([f] [f g] [f g h]), :arglists ([f] [f g] [f g h] [f g h & fs]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/juxt, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([f] [f g] [f g h]), :arglists ([f] [f g] [f g h] [f g h & fs]), :arglists-meta (nil nil nil nil)}, :method-params ([f] [f g] [f g h]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 9024, :end-line 9024, :max-fixed-arity 3, :fn-var true, :arglists ([f] [f g] [f g h] [f g h & fs]), :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]"}, ->PersistentQueueIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5665, :column 10, :end-line 5665, :end-column 29, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([fseq riter]))}, :protocols #{cljs.core/Object}, :name cljs.core/->PersistentQueueIter, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([fseq riter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5665, :end-line 5665, :max-fixed-arity 2, :fn-var true, :arglists (quote ([fseq riter])), :skip-protocol-flag nil}, < {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2472, :column 16, :end-line 2472, :end-column 17, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/<, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2472, :ret-tag boolean, :end-line 2472, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false."}, inode-kv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6481, :column 8, :end-line 6481, :end-column 23, :private true, :arglists (quote ([arr f init]))}, :private true, :name cljs.core/inode-kv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([arr f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6481, :end-line 6481, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr f init]))}, obj-map->hash-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5842, :column 8, :end-line 5842, :end-column 25, :private true, :arglists (quote ([m k v]))}, :private true, :name cljs.core/obj-map->hash-map, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5842, :end-line 5842, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v]))}, test {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10374, :column 7, :end-line 10374, :end-column 11, :arglists (quote ([v])), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception"}, :name cljs.core/test, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10374, :end-line 10374, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception"}, rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1138, :column 12, :end-line 1138, :end-column 16, :tag seq, :arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument."}, :name cljs.core/rest, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1138, :ret-tag seq, :end-line 1138, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument."}, ex-data {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10338, :column 7, :end-line 10338, :end-column 14, :arglists (quote ([ex])), :doc "Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil."}, :name cljs.core/ex-data, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10338, :end-line 10338, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil."}, PersistentArrayMapSeq {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/PersistentArrayMapSeq, :file "cljs/core.cljs", :end-column 31, :type true, :column 10, :line 6094, :record false, :end-line 6094, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -drop-first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 726, :column 4, :end-line 726, :end-column 15, :protocol cljs.core/IChunk, :doc "Return a new chunk of coll with the first item removed.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunk, :name cljs.core/-drop-first, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 724, :end-line 726, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a new chunk of coll with the first item removed."}, isa? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9851, :column 16, :end-line 9851, :end-column 20, :tag boolean, :arglists (quote ([child parent] [h child parent])), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([child parent] [h child parent]), :arglists ([child parent] [h child parent]), :arglists-meta (nil nil)}}, :name cljs.core/isa?, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([child parent] [h child parent]), :arglists ([child parent] [h child parent]), :arglists-meta (nil nil)}, :method-params ([child parent] [h child parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9851, :ret-tag boolean, :end-line 9851, :max-fixed-arity 3, :tag boolean, :fn-var true, :arglists ([child parent] [h child parent]), :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy"}, boolean? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2099, :column 16, :end-line 2099, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a Boolean"}, :name cljs.core/boolean?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2099, :ret-tag boolean, :end-line 2099, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a Boolean"}, -clone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 473, :column 9, :end-line 473, :end-column 15, :tag clj, :protocol cljs.core/ICloneable, :doc "Creates a clone of value.", :arglists (quote ([value]))}, :protocol cljs.core/ICloneable, :name cljs.core/-clone, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 471, :ret-tag clj, :end-line 473, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([value])), :doc "Creates a clone of value."}, munge {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10483, :column 7, :end-line 10483, :end-column 12, :arglists (quote ([name]))}, :name cljs.core/munge, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10483, :end-line 10483, :max-fixed-arity 1, :fn-var true, :arglists (quote ([name]))}, empty-ordered-hash {:name cljs.core/empty-ordered-hash, :file "cljs/core.cljs", :line 1238, :column 1, :end-line 1238, :end-column 34, :private true, :meta {:file "cljs/core.cljs", :line 1238, :column 16, :end-line 1238, :end-column 34, :private true}}, DEMUNGE_MAP {:name cljs.core/DEMUNGE_MAP, :file "cljs/core.cljs", :line 318, :column 1, :end-line 319, :end-column 14, :jsdoc ["@enum {string}"], :meta {:file "cljs/core.cljs", :line 319, :column 3, :end-line 319, :end-column 14, :jsdoc ["@enum {string}"]}}, ->t_cljs$core9607 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta9608])), :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t_cljs$core9607, :variadic false, :file "cljs/core.cljs", :method-params ([meta9608]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :line 3785, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta9608])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, ES6IteratorSeq {:num-fields 3, :protocols #{cljs.core/ISeq cljs.core/ISeqable}, :name cljs.core/ES6IteratorSeq, :file "cljs/core.cljs", :end-column 24, :type true, :column 10, :line 1195, :record false, :end-line 1195, :skip-protocol-flag #{cljs.core/ISeq cljs.core/ISeqable}}, ->NeverEquiv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5798, :column 10, :end-line 5798, :end-column 20, :protocols #{cljs.core/IEquiv cljs.core/Object}, :skip-protocol-flag #{cljs.core/IEquiv}, :factory :positional, :arglists (quote ([]))}, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/->NeverEquiv, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5798, :end-line 5798, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :skip-protocol-flag #{cljs.core/IEquiv}}, re-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9120, :column 7, :end-line 9120, :end-column 13, :arglists (quote ([re s])), :doc "Returns a lazy sequence of successive matches of re in s."}, :name cljs.core/re-seq, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9120, :end-line 9120, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns a lazy sequence of successive matches of re in s."}, char? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 231, :column 16, :end-line 231, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string of length one."}, :name cljs.core/char?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 231, :ret-tag boolean, :end-line 231, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string of length one."}, make-hierarchy {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9834, :column 7, :end-line 9834, :end-column 21, :arglists (quote ([])), :doc "Creates a hierarchy object for use with derive, isa? etc."}, :name cljs.core/make-hierarchy, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9834, :end-line 9834, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Creates a hierarchy object for use with derive, isa? etc."}, Symbol {:meta {:file "cljs/core.cljs", :line 854, :column 15, :end-line 854, :end-column 21, :declared true}, :num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/Symbol, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 962, :record false, :declared true, :end-line 962, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}}, PROTOCOL_SENTINEL {:name cljs.core/PROTOCOL_SENTINEL, :file "cljs/core.cljs", :line 22, :column 1, :end-line 22, :end-column 27, :meta {:file "cljs/core.cljs", :line 22, :column 10, :end-line 22, :end-column 27}}, tv-push-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5490, :column 8, :end-line 5490, :end-column 20, :private true, :arglists (quote ([tv level parent tail-node]))}, :private true, :name cljs.core/tv-push-tail, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([tv level parent tail-node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5490, :end-line 5490, :max-fixed-arity 4, :fn-var true, :arglists (quote ([tv level parent tail-node]))}, -reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 594, :column 4, :end-line 594, :end-column 11, :protocol cljs.core/IReduce, :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :arglists (quote ([coll f] [coll f start])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll f] [coll f start]), :arglists ([coll f] [coll f start]), :arglists-meta (nil nil)}}, :protocol cljs.core/IReduce, :name cljs.core/-reduce, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll f] [coll f start]), :arglists ([coll f] [coll f start]), :arglists-meta (nil nil)}, :method-params ([coll f] [coll f start]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 591, :end-line 594, :max-fixed-arity 3, :fn-var true, :arglists ([coll f] [coll f start]), :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc."}, -count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 478, :column 12, :end-line 478, :end-column 18, :tag number, :protocol cljs.core/ICounted, :doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :arglists (quote ([coll]))}, :protocol cljs.core/ICounted, :name cljs.core/-count, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 476, :ret-tag number, :end-line 478, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Calculates the count of coll in constant time. Used by cljs.core/count."}, keep {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4193, :column 7, :end-line 4193, :end-column 11, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/keep, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4193, :end-line 4193, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided."}, char {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2540, :column 7, :end-line 2540, :end-column 11, :arglists (quote ([x])), :doc "Coerce to char"}, :name cljs.core/char, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2540, :end-line 2540, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to char"}, mapcat {:protocol-inline nil, :meta {:added "1.0", :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & colls]), :arglists-meta (nil nil)}, :column 7, :line 4694, :end-line 4694, :arglists (quote ([f] [f & colls])), :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided"}, :added "1.0", :name cljs.core/mapcat, :variadic true, :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & colls]), :arglists-meta (nil nil)}, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4694, :end-line 4694, :max-fixed-arity 1, :fn-var true, :arglists ([f] [f & colls]), :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided"}, unchecked-long {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2654, :column 7, :end-line 2654, :end-column 21, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, :name cljs.core/unchecked-long, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2654, :end-line 2654, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, m3-seed {:name cljs.core/m3-seed, :file "cljs/core.cljs", :line 812, :column 1, :end-line 812, :end-column 13, :meta {:file "cljs/core.cljs", :line 812, :column 6, :end-line 812, :end-column 13}}, some? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 215, :column 16, :end-line 215, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is not nil, false otherwise."}, :name cljs.core/some?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 215, :ret-tag boolean, :end-line 215, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is not nil, false otherwise."}, unchecked-negate {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2609, :column 7, :end-line 2609, :end-column 23, :arglists (quote ([x]))}, :name cljs.core/unchecked-negate, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2609, :end-line 2609, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, symbol-identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3178, :column 16, :end-line 3178, :end-column 33, :tag boolean, :arglists (quote ([x y])), :doc "Efficient test to determine that two symbols are identical."}, :name cljs.core/symbol-identical?, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3178, :ret-tag boolean, :end-line 3178, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Efficient test to determine that two symbols are identical."}, reverse {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3032, :column 7, :end-line 3032, :end-column 14, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reverse order. Not lazy."}, :name cljs.core/reverse, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3032, :end-line 3032, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reverse order. Not lazy."}, inst? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1291, :column 16, :end-line 1291, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies Inst"}, :name cljs.core/inst?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1291, :ret-tag boolean, :end-line 1291, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies Inst"}, range {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8923, :column 7, :end-line 8923, :end-column 12, :arglists (quote ([] [end] [start end] [start end step])), :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([] [end] [start end] [start end step]), :arglists ([] [end] [start end] [start end step]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/range, :variadic false, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([] [end] [start end] [start end step]), :arglists ([] [end] [start end] [start end step]), :arglists-meta (nil nil nil nil)}, :method-params ([] [end] [start end] [start end step]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 8923, :end-line 8923, :max-fixed-arity 3, :fn-var true, :arglists ([] [end] [start end] [start end step]), :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity."}, bit-count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2754, :column 7, :end-line 2754, :end-column 16, :arglists (quote ([v])), :doc "Counts the number of bits set in n"}, :name cljs.core/bit-count, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2754, :end-line 2754, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v])), :doc "Counts the number of bits set in n"}, create-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6984, :column 8, :end-line 6984, :end-column 19, :private true, :arglists (quote ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2])), :top-fn {:variadic false, :max-fixed-arity 7, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/create-node, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 7, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :arglists-meta (nil nil)}, :method-params ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6984, :end-line 6984, :max-fixed-arity 7, :fn-var true, :arglists ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2])}, sort {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2305, :column 7, :end-line 2305, :end-column 11, :arglists (quote ([coll] [comp coll])), :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [comp coll]), :arglists ([coll] [comp coll]), :arglists-meta (nil nil)}}, :name cljs.core/sort, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [comp coll]), :arglists ([coll] [comp coll]), :arglists-meta (nil nil)}, :method-params ([coll] [comp coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2305, :end-line 2305, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [comp coll]), :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare."}, ->MetaFn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1894, :column 10, :end-line 1894, :end-column 16, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([afn meta]))}, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/->MetaFn, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([afn meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1894, :end-line 1894, :max-fixed-arity 2, :fn-var true, :arglists (quote ([afn meta])), :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, unchecked-inc-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2592, :column 7, :end-line 2592, :end-column 24, :arglists (quote ([x]))}, :name cljs.core/unchecked-inc-int, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2592, :end-line 2592, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -compare {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 720, :column 12, :end-line 720, :end-column 20, :tag number, :protocol cljs.core/IComparable, :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :arglists (quote ([x y]))}, :protocol cljs.core/IComparable, :name cljs.core/-compare, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 718, :ret-tag number, :end-line 720, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y."}, map-indexed {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4165, :column 7, :end-line 4165, :end-column 18, :arglists (quote ([f] [f coll])), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/map-indexed, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4165, :end-line 4165, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided."}, array-list {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8726, :column 7, :end-line 8726, :end-column 17, :arglists (quote ([]))}, :name cljs.core/array-list, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8726, :end-line 8726, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, rand-nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9815, :column 7, :end-line 9815, :end-column 15, :arglists (quote ([coll])), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection."}, :name cljs.core/rand-nth, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9815, :end-line 9815, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection."}, comp {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4082, :column 7, :end-line 4082, :end-column 11, :arglists (quote ([] [f] [f g] [f g h] [f1 f2 f3 & fs])), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([] [f] [f g] [f g h]), :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/comp, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([] [f] [f g] [f g h]), :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs]), :arglists-meta (nil nil nil nil nil)}, :method-params ([] [f] [f g] [f g h]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 4082, :end-line 4082, :max-fixed-arity 3, :fn-var true, :arglists ([] [f] [f g] [f g h] [f1 f2 f3 & fs]), :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc."}, array-chunk {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3367, :column 7, :end-line 3367, :end-column 18, :arglists (quote ([arr] [arr off] [arr off end])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([arr] [arr off] [arr off end]), :arglists ([arr] [arr off] [arr off end]), :arglists-meta (nil nil nil)}}, :name cljs.core/array-chunk, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([arr] [arr off] [arr off end]), :arglists ([arr] [arr off] [arr off end]), :arglists-meta (nil nil nil)}, :method-params ([arr] [arr off] [arr off end]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 3367, :end-line 3367, :max-fixed-arity 3, :fn-var true, :arglists ([arr] [arr off] [arr off end])}, dispatch-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10237, :column 7, :end-line 10237, :end-column 18, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's dispatch-fn."}, :name cljs.core/dispatch-fn, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10237, :end-line 10237, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's dispatch-fn."}, bit-shift-right-zero-fill {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2746, :column 7, :end-line 2746, :end-column 32, :arglists (quote ([x n])), :doc "DEPRECATED: Bitwise shift right with zero fill"}, :name cljs.core/bit-shift-right-zero-fill, :variadic false, :file "cljs/core.cljs", :end-column 32, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2746, :end-line 2746, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "DEPRECATED: Bitwise shift right with zero fill"}, js-reserved? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10448, :column 8, :end-line 10448, :end-column 20, :private true, :arglists (quote ([x]))}, :private true, :name cljs.core/js-reserved?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10448, :end-line 10448, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -as-transient {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 685, :column 9, :end-line 685, :end-column 22, :tag clj, :protocol cljs.core/IEditableCollection, :doc "Returns a new, transient version of the collection, in constant time.", :arglists (quote ([coll]))}, :protocol cljs.core/IEditableCollection, :name cljs.core/-as-transient, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 683, :ret-tag clj, :end-line 685, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, dorun {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9060, :column 7, :end-line 9060, :end-column 12, :arglists (quote ([coll] [n coll])), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/dorun, :variadic false, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [n coll]), :arglists ([coll] [n coll]), :arglists-meta (nil nil)}, :method-params ([coll] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9060, :end-line 9060, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [n coll]), :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil."}, ->t_cljs$core7894 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta7895])), :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t_cljs$core7894, :variadic false, :file "cljs/core.cljs", :method-params ([meta7895]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :line 3785, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta7895])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, pr-sequential-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9140, :column 7, :end-line 9140, :end-column 27, :arglists (quote ([writer print-one begin sep end opts coll]))}, :name cljs.core/pr-sequential-writer, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([writer print-one begin sep end opts coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9140, :end-line 9140, :max-fixed-arity 7, :fn-var true, :arglists (quote ([writer print-one begin sep end opts coll]))}, simple-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3206, :column 16, :end-line 3206, :end-column 30, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a symbol without a namespace"}, :name cljs.core/simple-symbol?, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3206, :ret-tag boolean, :end-line 3206, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a symbol without a namespace"}, accumulating-seq-count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1695, :column 8, :end-line 1695, :end-column 30, :private true, :arglists (quote ([coll]))}, :private true, :name cljs.core/accumulating-seq-count, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1695, :end-line 1695, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, IIndexed {:meta {:file "cljs/core.cljs", :line 498, :column 14, :end-line 498, :end-column 22, :doc "Protocol for collections to provide indexed-based access to their items.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-nth [[coll n] [coll n not-found]]}}}, :protocol-symbol true, :name cljs.core/IIndexed, :file "cljs/core.cljs", :end-column 22, :column 1, :line 498, :protocol-info {:methods {-nth [[coll n] [coll n not-found]]}}, :info nil, :end-line 498, :impls #{cljs.core/TransientVector cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/ArrayChunk cljs.core/Range cljs.core/RedNode}, :doc "Protocol for collections to provide indexed-based access to their items.", :jsdoc ("@interface")}, disj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1978, :column 7, :end-line 1978, :end-column 11, :arglists (quote ([coll] [coll k] [coll k & ks])), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}}, :name cljs.core/disj, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [coll k]), :arglists ([coll] [coll k] [coll k & ks]), :arglists-meta (nil nil nil)}, :method-params ([coll] [coll k]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1978, :end-line 1978, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [coll k] [coll k & ks]), :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s)."}, IPrintWithWriter {:meta {:file "cljs/core.cljs", :line 659, :column 14, :end-line 659, :end-column 30, :doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-pr-writer [[o writer opts]]}}}, :protocol-symbol true, :name cljs.core/IPrintWithWriter, :file "cljs/core.cljs", :end-column 30, :column 1, :line 659, :protocol-info {:methods {-pr-writer [[o writer opts]]}}, :info nil, :end-line 659, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Volatile cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ExceptionInfo cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/TaggedLiteral cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.", :jsdoc ("@interface")}, ->UUID {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10244, :column 10, :end-line 10244, :end-column 14, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable cljs.core/IUUID}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}, :factory :positional, :arglists (quote ([uuid __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IComparable cljs.core/IUUID}, :name cljs.core/->UUID, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([uuid __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 10244, :end-line 10244, :max-fixed-arity 2, :fn-var true, :arglists (quote ([uuid __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/IComparable}}, IVector {:meta {:file "cljs/core.cljs", :line 568, :column 14, :end-line 568, :end-column 21, :doc "Protocol for adding vector functionality to collections.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-assoc-n [[coll n val]]}}}, :protocol-symbol true, :name cljs.core/IVector, :file "cljs/core.cljs", :end-column 21, :column 1, :line 568, :protocol-info {:methods {-assoc-n [[coll n val]]}}, :info nil, :end-line 568, :impls #{cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/RedNode}, :doc "Protocol for adding vector functionality to collections.", :jsdoc ("@interface")}, IIterable {:meta {:file "cljs/core.cljs", :line 767, :column 14, :end-line 767, :end-column 23, :doc "Protocol for iterating over a collection.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-iterator [[coll]]}}}, :protocol-symbol true, :name cljs.core/IIterable, :file "cljs/core.cljs", :end-column 23, :column 1, :line 767, :protocol-info {:methods {-iterator [[coll]]}}, :info nil, :end-line 767, :impls #{cljs.core/PersistentHashMap cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/PersistentVector cljs.core/ArrayNode cljs.core/PersistentHashSet cljs.core/HashCollisionNode cljs.core/Range cljs.core/BitmapIndexedNode}, :doc "Protocol for iterating over a collection.", :jsdoc ("@interface")}, *2 {:name cljs.core/*2, :file "cljs/core.cljs", :line 164, :column 1, :end-line 166, :end-column 5, :doc "bound in a repl thread to the second most recent value printed", :meta {:file "cljs/core.cljs", :line 166, :column 3, :end-line 166, :end-column 5, :doc "bound in a repl thread to the second most recent value printed"}}, Eduction {:num-fields 2, :protocols #{cljs.core/Object cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}, :name cljs.core/Eduction, :file "cljs/core.cljs", :end-column 18, :type true, :column 10, :line 9661, :record false, :end-line 9661, :skip-protocol-flag #{cljs.core/ISeqable cljs.core/IPrintWithWriter cljs.core/ISequential cljs.core/IReduce}}, pv-clone-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4911, :column 8, :end-line 4911, :end-column 21, :private true, :arglists (quote ([node]))}, :private true, :name cljs.core/pv-clone-node, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4911, :end-line 4911, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, cons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3113, :column 7, :end-line 3113, :end-column 11, :arglists (quote ([x coll])), :doc "Returns a new seq where x is the first element and coll is the rest."}, :name cljs.core/cons, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3113, :end-line 3113, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x coll])), :doc "Returns a new seq where x is the first element and coll is the rest."}, PersistentTreeSet {:num-fields 3, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentTreeSet, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 8498, :record false, :end-line 8498, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, ->HashSetIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8352, :column 10, :end-line 8352, :end-column 21, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([iter]))}, :protocols #{cljs.core/Object}, :name cljs.core/->HashSetIter, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8352, :end-line 8352, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iter])), :skip-protocol-flag nil}, ns-lookup {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10520, :column 8, :end-line 10520, :end-column 17, :private true, :arglists (quote ([ns-obj k])), :doc "Bootstrap only."}, :private true, :name cljs.core/ns-lookup, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([ns-obj k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10520, :end-line 10520, :max-fixed-arity 2, :fn-var true, :arglists (quote ([ns-obj k])), :doc "Bootstrap only."}, floats {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2664, :column 7, :end-line 2664, :end-column 13, :arglists (quote ([x]))}, :name cljs.core/floats, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2664, :end-line 2664, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, TransientVector {:meta {:file "cljs/core.cljs", :line 5016, :column 44, :end-line 5016, :end-column 59, :declared true}, :num-fields 4, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientVector, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 5532, :record false, :declared true, :end-line 5532, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}}, pos? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2774, :column 16, :end-line 2774, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if num is greater than zero, else false"}, :name cljs.core/pos?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2774, :ret-tag boolean, :end-line 2774, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if num is greater than zero, else false"}, fnil {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4140, :column 7, :end-line 4140, :end-column 11, :arglists (quote ([f x] [f x y] [f x y z])), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([f x] [f x y] [f x y z]), :arglists ([f x] [f x y] [f x y z]), :arglists-meta (nil nil nil)}}, :name cljs.core/fnil, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([f x] [f x y] [f x y z]), :arglists ([f x] [f x y] [f x y z]), :arglists-meta (nil nil nil)}, :method-params ([f x] [f x y] [f x y z]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 4140, :end-line 4140, :max-fixed-arity 4, :fn-var true, :arglists ([f x] [f x y] [f x y z]), :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched."}, merge-with {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8318, :column 7, :end-line 8318, :end-column 17, :arglists (quote ([f & maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}}, :name cljs.core/merge-with, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f maps)], :arglists ([f & maps]), :arglists-meta (nil)}, :method-params [(f maps)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8318, :end-line 8318, :max-fixed-arity 1, :fn-var true, :arglists ([f & maps]), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter)."}, nthrest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1808, :column 7, :end-line 1808, :end-column 14, :arglists (quote ([coll n])), :doc "Returns the nth rest of coll, coll when n is 0."}, :name cljs.core/nthrest, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1808, :end-line 1808, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth rest of coll, coll when n is 0."}, sequential? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2016, :column 16, :end-line 2016, :end-column 27, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISequential"}, :name cljs.core/sequential?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2016, :ret-tag boolean, :end-line 2016, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISequential"}, tree-map-replace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7949, :column 8, :end-line 7949, :end-column 24, :private true, :arglists (quote ([comp tree k v]))}, :private true, :name cljs.core/tree-map-replace, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([comp tree k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7949, :end-line 7949, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k v]))}, m3-mix-H1 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 819, :column 15, :end-line 819, :end-column 24, :tag number, :arglists (quote ([h1 k1]))}, :name cljs.core/m3-mix-H1, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([h1 k1]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 819, :ret-tag number, :end-line 819, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 k1]))}, RecordIter {:num-fields 5, :protocols #{cljs.core/Object}, :name cljs.core/RecordIter, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 5977, :record false, :end-line 5977, :skip-protocol-flag nil}, ->TransientArrayMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6357, :column 10, :end-line 6357, :end-column 27, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :factory :positional, :arglists (quote ([editable? len arr]))}, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientArrayMap, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([editable? len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6357, :end-line 6357, :max-fixed-arity 3, :fn-var true, :arglists (quote ([editable? len arr])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, prim-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1557, :column 7, :end-line 1557, :end-column 15, :arglists (quote ([prim] [prim i])), :doc "Create seq from a primitive JavaScript Array-like.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prim] [prim i]), :arglists ([prim] [prim i]), :arglists-meta (nil nil)}}, :name cljs.core/prim-seq, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prim] [prim i]), :arglists ([prim] [prim i]), :arglists-meta (nil nil)}, :method-params ([prim] [prim i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1557, :end-line 1557, :max-fixed-arity 2, :fn-var true, :arglists ([prim] [prim i]), :doc "Create seq from a primitive JavaScript Array-like."}, *print-level* {:meta {:file "cljs/core.cljs", :line 132, :column 3, :end-line 132, :end-column 16, :dynamic true, :doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :jsdoc ["@type {null|number}"]}, :name cljs.core/*print-level*, :file "cljs/core.cljs", :end-column 16, :column 1, :dynamic true, :line 121, :end-line 132, :doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :jsdoc ["@type {null|number}"]}, shuffle {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2346, :column 7, :end-line 2346, :end-column 14, :arglists (quote ([coll])), :doc "Return a random permutation of coll"}, :name cljs.core/shuffle, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2346, :end-line 2346, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Return a random permutation of coll"}, ChunkedSeq {:meta {:file "cljs/core.cljs", :line 2044, :column 22, :end-line 2044, :end-column 32, :declared true}, :num-fields 6, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ChunkedSeq, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 5249, :record false, :declared true, :end-line 5249, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, hash-keyword {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3121, :column 7, :end-line 3121, :end-column 19, :arglists (quote ([k]))}, :name cljs.core/hash-keyword, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3121, :end-line 3121, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, find {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2221, :column 7, :end-line 2221, :end-column 11, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present."}, :name cljs.core/find, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2221, :end-line 2221, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll k])), :doc "Returns the map entry for key, or nil if key not present."}, alength {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 417, :column 15, :end-line 417, :end-column 22, :tag number, :arglists (quote ([array])), :doc "Returns the length of the array. Works on arrays of all types."}, :name cljs.core/alength, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([array]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 417, :ret-tag number, :end-line 417, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([array])), :doc "Returns the length of the array. Works on arrays of all types."}, bit-xor {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2690, :column 7, :end-line 2690, :end-column 14, :arglists (quote ([x y] [x y & more])), :doc "Bitwise exclusive or", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-xor, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2690, :end-line 2690, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise exclusive or"}, ->IndexedSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1470, :column 10, :end-line 1470, :end-column 20, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([arr i meta]))}, :protocols #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->IndexedSeq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([arr i meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1470, :end-line 1470, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i meta])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, ObjMap {:num-fields 5, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/ObjMap, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 5866, :record false, :end-line 5866, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, unsigned-bit-shift-right {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2750, :column 7, :end-line 2750, :end-column 31, :arglists (quote ([x n])), :doc "Bitwise shift right with zero fill"}, :name cljs.core/unsigned-bit-shift-right, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2750, :end-line 2750, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Bitwise shift right with zero fill"}, ES6SetEntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6SetEntriesIterator, :file "cljs/core.cljs", :end-column 31, :type true, :column 10, :line 6003, :record false, :end-line 6003, :skip-protocol-flag nil}, neg? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2783, :column 16, :end-line 2783, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if num is less than zero, else false"}, :name cljs.core/neg?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2783, :ret-tag boolean, :end-line 2783, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if num is less than zero, else false"}, Cons {:num-fields 4, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Cons, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 3056, :record false, :end-line 3056, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -remove-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10006, :column 4, :end-line 10006, :end-column 18, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-remove-method, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10003, :end-line 10006, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :doc nil}, ->StringIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3791, :column 10, :end-line 3791, :end-column 20, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s i]))}, :protocols #{cljs.core/Object}, :name cljs.core/->StringIter, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([s i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3791, :end-line 3791, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s i])), :skip-protocol-flag nil}, js-invoke {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 432, :column 7, :end-line 432, :end-column 16, :arglists (quote ([obj s & args])), :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(obj s args)], :arglists ([obj s & args]), :arglists-meta (nil)}}, :name cljs.core/js-invoke, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(obj s args)], :arglists ([obj s & args]), :arglists-meta (nil)}, :method-params [(obj s args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 432, :end-line 432, :max-fixed-arity 2, :fn-var true, :arglists ([obj s & args]), :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name."}, ->List {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2879, :column 10, :end-line 2879, :end-column 14, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta first rest count __hash]))}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->List, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([meta first rest count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 2879, :end-line 2879, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta first rest count __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, m3-mix-K1 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 816, :column 15, :end-line 816, :end-column 24, :tag number, :arglists (quote ([k1]))}, :name cljs.core/m3-mix-K1, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([k1]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 816, :ret-tag number, :end-line 816, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([k1]))}, unchecked-float {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2555, :column 15, :end-line 2555, :end-column 30, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-float, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2555, :ret-tag number, :end-line 2555, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, undefined? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2103, :column 16, :end-line 2103, :end-column 26, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x identical to the JavaScript undefined value."}, :name cljs.core/undefined?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2103, :ret-tag boolean, :end-line 2103, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x identical to the JavaScript undefined value."}, IMeta {:meta {:file "cljs/core.cljs", :line 581, :column 14, :end-line 581, :end-column 19, :doc "Protocol for accessing the metadata of an object.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-meta [[o]]}}}, :protocol-symbol true, :name cljs.core/IMeta, :file "cljs/core.cljs", :end-column 19, :column 1, :line 581, :protocol-info {:methods {-meta [[o]]}}, :info nil, :end-line 581, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/t_cljs$core9610 cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet function cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/t_cljs$core9607 cljs.core/RedNode}, :doc "Protocol for accessing the metadata of an object.", :jsdoc ("@interface")}, reduced? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1328, :column 16, :end-line 1328, :end-column 24, :tag boolean, :arglists (quote ([r])), :doc "Returns true if x is the result of a call to reduced"}, :name cljs.core/reduced?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([r]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1328, :ret-tag boolean, :end-line 1328, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([r])), :doc "Returns true if x is the result of a call to reduced"}, apply-to {:protocol-inline nil, :meta {:arglists (quote ([f argc args])), :file "cljs/core.cljs"}, :name cljs.core/apply-to, :variadic false, :file "cljs/core.cljs", :method-params ([f argc args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3706, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f argc args]))}, disj! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3691, :column 7, :end-line 3691, :end-column 12, :arglists (quote ([tcoll val] [tcoll val & vals])), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll val]), :arglists ([tcoll val] [tcoll val & vals]), :arglists-meta (nil nil)}}, :name cljs.core/disj!, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll val]), :arglists ([tcoll val] [tcoll val & vals]), :arglists-meta (nil nil)}, :method-params ([tcoll val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3691, :end-line 3691, :max-fixed-arity 2, :fn-var true, :arglists ([tcoll val] [tcoll val & vals]), :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s)."}, -lookup {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 527, :column 4, :end-line 527, :end-column 11, :protocol cljs.core/ILookup, :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :arglists (quote ([o k] [o k not-found])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}}, :protocol cljs.core/ILookup, :name cljs.core/-lookup, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}, :method-params ([o k] [o k not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 525, :end-line 527, :max-fixed-arity 3, :fn-var true, :arglists ([o k] [o k not-found]), :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned."}, float? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2194, :column 16, :end-line 2194, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "Returns true for JavaScript numbers, false otherwise."}, :name cljs.core/float?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2194, :ret-tag boolean, :end-line 2194, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true for JavaScript numbers, false otherwise."}, ICloneable {:meta {:file "cljs/core.cljs", :line 471, :column 14, :end-line 471, :end-column 24, :doc "Protocol for cloning a value.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-clone [[value]]}}}, :protocol-symbol true, :name cljs.core/ICloneable, :file "cljs/core.cljs", :end-column 24, :column 1, :line 471, :protocol-info {:methods {-clone [[value]]}}, :info nil, :end-line 471, :impls #{cljs.core/PersistentHashMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Range}, :doc "Protocol for cloning a value.", :jsdoc ("@interface")}, IEncodeClojure {:meta {:file "cljs/core.cljs", :line 9741, :column 14, :end-line 9741, :end-column 28, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-js->clj [[x options]]}}}, :protocol-symbol true, :name cljs.core/IEncodeClojure, :file "cljs/core.cljs", :end-column 28, :column 1, :line 9741, :protocol-info {:methods {-js->clj [[x options]]}}, :info nil, :end-line 9741, :impls #{}, :doc nil, :jsdoc ("@interface")}, booleans {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2659, :column 7, :end-line 2659, :end-column 15, :arglists (quote ([x]))}, :name cljs.core/booleans, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2659, :end-line 2659, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->ArrayList {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8718, :column 10, :end-line 8718, :end-column 19, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayList, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8718, :end-line 8718, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr])), :skip-protocol-flag nil}, RSeq {:meta {:file "cljs/core.cljs", :line 1417, :column 40, :end-line 1417, :end-column 44, :declared true}, :num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/RSeq, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 1574, :record false, :declared true, :end-line 1574, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, mask {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6446, :column 8, :end-line 6446, :end-column 12, :private true, :arglists (quote ([hash shift]))}, :private true, :name cljs.core/mask, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6446, :end-line 6446, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift]))}, int-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3492, :column 7, :end-line 3492, :end-column 16, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/int-array, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3492, :end-line 3492, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure."}, find-and-cache-best-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9978, :column 8, :end-line 9978, :end-column 34, :private true, :arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]))}, :private true, :name cljs.core/find-and-cache-best-method, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9978, :end-line 9978, :max-fixed-arity 7, :fn-var true, :arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]))}, set? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2005, :column 16, :end-line 2005, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x satisfies ISet"}, :name cljs.core/set?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2005, :ret-tag boolean, :end-line 2005, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ISet"}, iterable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1089, :column 16, :end-line 1089, :end-column 25, :tag boolean, :arglists (quote ([x])), :doc "Return true if x implements IIterable protocol."}, :name cljs.core/iterable?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1089, :ret-tag boolean, :end-line 1089, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x implements IIterable protocol."}, cat {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9622, :column 7, :end-line 9622, :end-column 10, :arglists (quote ([rf])), :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", :added "1.7"}, :added "1.7", :name cljs.core/cat, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9622, :end-line 9622, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf])), :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction."}, ->ES6EntriesIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5990, :column 10, :end-line 5990, :end-column 28, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([s]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ES6EntriesIterator, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5990, :end-line 5990, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :skip-protocol-flag nil}, divide {:name cljs.core/divide, :file "cljs/core.cljs", :line 2463, :column 1, :end-line 2463, :end-column 16, :declared true, :meta {:file "cljs/core.cljs", :line 2463, :column 10, :end-line 2463, :end-column 16, :declared true}}, js-reserved-arr {:name cljs.core/js-reserved-arr, :file "cljs/core.cljs", :line 10426, :column 1, :end-line 10429, :end-column 18, :private true, :jsdoc ["@type {*}"], :meta {:file "cljs/core.cljs", :line 10429, :column 3, :end-line 10429, :end-column 18, :private true, :jsdoc ["@type {*}"]}}, -pr-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 665, :column 4, :end-line 665, :end-column 14, :protocol cljs.core/IPrintWithWriter, :doc nil, :arglists (quote ([o writer opts]))}, :protocol cljs.core/IPrintWithWriter, :name cljs.core/-pr-writer, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([o writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 659, :end-line 665, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o writer opts])), :doc nil}, flush {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9171, :column 7, :end-line 9171, :end-column 12, :arglists (quote ([]))}, :name cljs.core/flush, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9171, :end-line 9171, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, set-from-indexed-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8591, :column 7, :end-line 8591, :end-column 27, :arglists (quote ([iseq]))}, :name cljs.core/set-from-indexed-seq, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([iseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8591, :end-line 8591, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iseq]))}, take-while {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8760, :column 7, :end-line 8760, :end-column 17, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/take-while, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8760, :end-line 8760, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, vary-meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3757, :column 7, :end-line 3757, :end-column 16, :arglists (quote ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args])), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d]), :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]), :arglists-meta (nil nil nil nil nil nil)}}, :name cljs.core/vary-meta, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d]), :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]), :arglists-meta (nil nil nil nil nil nil)}, :method-params ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil nil), :column 1, :line 3757, :end-line 3757, :max-fixed-arity 6, :fn-var true, :arglists ([obj f] [obj f a] [obj f a b] [obj f a b c] [obj f a b c d] [obj f a b c d & args]), :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata."}, INext {:meta {:file "cljs/core.cljs", :line 517, :column 14, :end-line 517, :end-column 19, :doc "Protocol for accessing the next items of a collection.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-next [[coll]]}}}, :protocol-symbol true, :name cljs.core/INext, :file "cljs/core.cljs", :end-column 19, :column 1, :line 517, :protocol-info {:methods {-next [[coll]]}}, :info nil, :end-line 517, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range}, :doc "Protocol for accessing the next items of a collection.", :jsdoc ("@interface")}, is_proto_ {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 251, :column 7, :end-line 251, :end-column 16, :arglists (quote ([x]))}, :name cljs.core/is_proto_, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 251, :end-line 251, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, START {:name cljs.core/START, :file "cljs/core.cljs", :line 3816, :column 1, :end-line 3816, :end-column 11, :meta {:file "cljs/core.cljs", :line 3816, :column 6, :end-line 3816, :end-column 11}}, ICounted {:meta {:file "cljs/core.cljs", :line 476, :column 14, :end-line 476, :end-column 22, :doc "Protocol for adding the ability to count a collection in constant time.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-count [[coll]]}}}, :protocol-symbol true, :name cljs.core/ICounted, :file "cljs/core.cljs", :end-column 22, :column 1, :line 476, :protocol-info {:methods {-count [[coll]]}}, :info nil, :end-line 476, :impls #{nil cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/Subvec cljs.core/TransientHashMap cljs.core/ChunkBuffer cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/TransientArrayMap cljs.core/RSeq cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/ArrayChunk cljs.core/PersistentTreeSet cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding the ability to count a collection in constant time.", :jsdoc ("@interface")}, IMapEntry {:meta {:file "cljs/core.cljs", :line 546, :column 14, :end-line 546, :end-column 23, :doc "Protocol for examining a map entry.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-key [[coll]], -val [[coll]]}}}, :protocol-symbol true, :name cljs.core/IMapEntry, :file "cljs/core.cljs", :end-column 23, :column 1, :line 546, :protocol-info {:methods {-key [[coll]], -val [[coll]]}}, :info nil, :end-line 546, :impls #{cljs.core/BlackNode cljs.core/PersistentVector cljs.core/RedNode}, :doc "Protocol for examining a map entry.", :jsdoc ("@interface")}, <= {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2484, :column 16, :end-line 2484, :end-column 18, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/<=, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2484, :ret-tag boolean, :end-line 2484, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false."}, conj! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3650, :column 7, :end-line 3650, :end-column 12, :arglists (quote ([] [tcoll] [tcoll val] [tcoll val & vals])), :doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [tcoll] [tcoll val]), :arglists ([] [tcoll] [tcoll val] [tcoll val & vals]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/conj!, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [tcoll] [tcoll val]), :arglists ([] [tcoll] [tcoll val] [tcoll val & vals]), :arglists-meta (nil nil nil nil)}, :method-params ([] [tcoll] [tcoll val]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 3650, :end-line 3650, :max-fixed-arity 2, :fn-var true, :arglists ([] [tcoll] [tcoll val] [tcoll val & vals]), :doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type."}, -pop {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 564, :column 9, :end-line 564, :end-column 13, :tag clj, :protocol cljs.core/IStack, :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :arglists (quote ([coll]))}, :protocol cljs.core/IStack, :name cljs.core/-pop, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 558, :ret-tag clj, :end-line 564, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop."}, array-index-of-identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6045, :column 8, :end-line 6045, :end-column 33, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-identical?, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6045, :end-line 6045, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, repeatedly {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4632, :column 7, :end-line 4632, :end-column 17, :arglists (quote ([f] [n f])), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [n f]), :arglists ([f] [n f]), :arglists-meta (nil nil)}}, :name cljs.core/repeatedly, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [n f]), :arglists ([f] [n f]), :arglists-meta (nil nil)}, :method-params ([f] [n f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4632, :end-line 4632, :max-fixed-arity 2, :fn-var true, :arglists ([f] [n f]), :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it"}, zipmap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8692, :column 7, :end-line 8692, :end-column 13, :arglists (quote ([keys vals])), :doc "Returns a map with the keys mapped to the corresponding vals."}, :name cljs.core/zipmap, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([keys vals]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8692, :end-line 8692, :max-fixed-arity 2, :fn-var true, :arglists (quote ([keys vals])), :doc "Returns a map with the keys mapped to the corresponding vals."}, IStack {:meta {:file "cljs/core.cljs", :line 558, :column 14, :end-line 558, :end-column 20, :doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-peek [[coll]], -pop [[coll]]}}}, :protocol-symbol true, :name cljs.core/IStack, :file "cljs/core.cljs", :end-column 20, :column 1, :line 558, :protocol-info {:methods {-peek [[coll]], -pop [[coll]]}}, :info nil, :end-line 558, :impls #{cljs.core/PersistentQueue cljs.core/BlackNode cljs.core/EmptyList cljs.core/Subvec cljs.core/PersistentVector cljs.core/List cljs.core/RedNode}, :doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.", :jsdoc ("@interface")}, -remove-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 680, :column 4, :end-line 680, :end-column 17, :protocol cljs.core/IWatchable, :doc "Removes watcher that corresponds to key from this.", :arglists (quote ([this key]))}, :protocol cljs.core/IWatchable, :name cljs.core/-remove-watch, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([this key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 673, :end-line 680, :max-fixed-arity 2, :fn-var true, :arglists (quote ([this key])), :doc "Removes watcher that corresponds to key from this."}, IVolatile {:meta {:file "cljs/core.cljs", :line 761, :column 14, :end-line 761, :end-column 23, :doc "Protocol for adding volatile functionality.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-vreset! [[o new-value]]}}}, :protocol-symbol true, :name cljs.core/IVolatile, :file "cljs/core.cljs", :end-column 23, :column 1, :line 761, :protocol-info {:methods {-vreset! [[o new-value]]}}, :info nil, :end-line 761, :impls #{cljs.core/Volatile}, :doc "Protocol for adding volatile functionality.", :jsdoc ("@interface")}, remove {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4733, :column 7, :end-line 4733, :end-column 13, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/remove, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4733, :end-line 4733, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, ->BitmapIndexedNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6537, :column 10, :end-line 6537, :end-column 27, :protocols #{cljs.core/Object cljs.core/IIterable}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([edit bitmap arr]))}, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/->BitmapIndexedNode, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([edit bitmap arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6537, :end-line 6537, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit bitmap arr])), :skip-protocol-flag nil}, * {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2456, :column 15, :end-line 2456, :end-column 16, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/*, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2456, :ret-tag number, :end-line 2456, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1."}, re-pattern {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9129, :column 7, :end-line 9129, :end-column 17, :arglists (quote ([s])), :doc "Returns an instance of RegExp which has compiled the provided string."}, :name cljs.core/re-pattern, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9129, :end-line 9129, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns an instance of RegExp which has compiled the provided string."}, min {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2531, :column 15, :end-line 2531, :end-column 18, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the least of the nums.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/min, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2531, :ret-tag number, :end-line 2531, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns the least of the nums."}, array-index-of-nil? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6017, :column 8, :end-line 6017, :end-column 27, :private true, :arglists (quote ([arr]))}, :private true, :name cljs.core/array-index-of-nil?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6017, :end-line 6017, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arr]))}, -persistent! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 692, :column 9, :end-line 692, :end-column 21, :tag clj, :protocol cljs.core/ITransientCollection, :doc "Creates a persistent data structure from tcoll and returns it.", :arglists (quote ([tcoll]))}, :protocol cljs.core/ITransientCollection, :name cljs.core/-persistent!, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 688, :ret-tag clj, :end-line 692, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :doc "Creates a persistent data structure from tcoll and returns it."}, -nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 500, :column 4, :end-line 500, :end-column 8, :protocol cljs.core/IIndexed, :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :arglists (quote ([coll n] [coll n not-found])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}}, :protocol cljs.core/IIndexed, :name cljs.core/-nth, :variadic false, :file "cljs/core.cljs", :end-column 8, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 498, :end-line 500, :max-fixed-arity 3, :fn-var true, :arglists ([coll n] [coll n not-found]), :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied."}, pop! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3685, :column 7, :end-line 3685, :end-column 11, :arglists (quote ([tcoll])), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll"}, :name cljs.core/pop!, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3685, :end-line 3685, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll"}, chunk-append {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3452, :column 7, :end-line 3452, :end-column 19, :arglists (quote ([b x]))}, :name cljs.core/chunk-append, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([b x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3452, :end-line 3452, :max-fixed-arity 2, :fn-var true, :arglists (quote ([b x]))}, prn-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9330, :column 7, :end-line 9330, :end-column 14, :arglists (quote ([& objs])), :doc "Same as pr-str followed by (newline)", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/prn-str, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9330, :end-line 9330, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Same as pr-str followed by (newline)"}, t_cljs$core9610 {:num-fields 1, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t_cljs$core9610, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3785, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, IReversible {:meta {:file "cljs/core.cljs", :line 630, :column 14, :end-line 630, :end-column 25, :doc "Protocol for reversing a seq.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-rseq [[coll]]}}}, :protocol-symbol true, :name cljs.core/IReversible, :file "cljs/core.cljs", :end-column 25, :column 1, :line 630, :protocol-info {:methods {-rseq [[coll]]}}, :info nil, :end-line 630, :impls #{cljs.core/IndexedSeq cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}, :doc "Protocol for reversing a seq.", :jsdoc ("@interface")}, reversible? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3021, :column 16, :end-line 3021, :end-column 27, :tag boolean, :arglists (quote ([coll])), :doc "Returns true if coll satisfies? IReversible."}, :name cljs.core/reversible?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3021, :ret-tag boolean, :end-line 3021, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll])), :doc "Returns true if coll satisfies? IReversible."}, -realized? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 670, :column 13, :end-line 670, :end-column 23, :tag boolean, :protocol cljs.core/IPending, :doc "Returns true if a value for x has been produced, false otherwise.", :arglists (quote ([x]))}, :protocol cljs.core/IPending, :name cljs.core/-realized?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 667, :ret-tag boolean, :end-line 670, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if a value for x has been produced, false otherwise."}, -add-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 677, :column 4, :end-line 677, :end-column 14, :protocol cljs.core/IWatchable, :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :arglists (quote ([this key f]))}, :protocol cljs.core/IWatchable, :name cljs.core/-add-watch, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([this key f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 673, :end-line 677, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this key f])), :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch."}, -deref-with-timeout {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 579, :column 4, :end-line 579, :end-column 23, :protocol cljs.core/IDerefWithTimeout, :doc nil, :arglists (quote ([o msec timeout-val]))}, :protocol cljs.core/IDerefWithTimeout, :name cljs.core/-deref-with-timeout, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([o msec timeout-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 578, :end-line 579, :max-fixed-arity 3, :fn-var true, :arglists (quote ([o msec timeout-val])), :doc nil}, conj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1674, :column 7, :end-line 1674, :end-column 11, :arglists (quote ([] [coll] [coll x] [coll x & xs])), :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [coll] [coll x]), :arglists ([] [coll] [coll x] [coll x & xs]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/conj, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [coll] [coll x]), :arglists ([] [coll] [coll x] [coll x & xs]), :arglists-meta (nil nil nil nil)}, :method-params ([] [coll] [coll x]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 1674, :end-line 1674, :max-fixed-arity 2, :fn-var true, :arglists ([] [coll] [coll x] [coll x & xs]), :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type."}, -sorted-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 638, :column 9, :end-line 638, :end-column 20, :tag clj, :protocol cljs.core/ISorted, :doc "Returns a sorted seq from coll in either ascending or descending order.", :arglists (quote ([coll ascending?]))}, :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([coll ascending?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 635, :ret-tag clj, :end-line 638, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll ascending?])), :doc "Returns a sorted seq from coll in either ascending or descending order."}, flatten1 {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4680, :column 8, :end-line 4680, :end-column 16, :private true, :arglists (quote ([colls])), :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection"}, :private true, :name cljs.core/flatten1, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4680, :end-line 4680, :max-fixed-arity 1, :fn-var true, :arglists (quote ([colls])), :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection"}, transduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2423, :column 7, :end-line 2423, :end-column 16, :arglists (quote ([xform f coll] [xform f init coll])), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xform f coll] [xform f init coll]), :arglists ([xform f coll] [xform f init coll]), :arglists-meta (nil nil)}}, :name cljs.core/transduce, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([xform f coll] [xform f init coll]), :arglists ([xform f coll] [xform f init coll]), :arglists-meta (nil nil)}, :method-params ([xform f coll] [xform f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2423, :end-line 2423, :max-fixed-arity 4, :fn-var true, :arglists ([xform f coll] [xform f init coll]), :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items."}, fixture1 {:name cljs.core/fixture1, :file "cljs/core.cljs", :line 9582, :column 1, :end-line 9582, :end-column 14, :meta {:file "cljs/core.cljs", :line 9582, :column 6, :end-line 9582, :end-column 14}}, -swap! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 758, :column 4, :end-line 758, :end-column 10, :protocol cljs.core/ISwap, :doc "Swaps the value of o to be (apply f current-value-of-atom args).", :arglists (quote ([o f] [o f a] [o f a b] [o f a b xs])), :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :arglists-meta (nil nil nil nil)}}, :protocol cljs.core/ISwap, :name cljs.core/-swap!, :variadic false, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :arglists-meta (nil nil nil nil)}, :method-params ([o f] [o f a] [o f a b] [o f a b xs]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 756, :end-line 758, :max-fixed-arity 5, :fn-var true, :arglists ([o f] [o f a] [o f a b] [o f a b xs]), :doc "Swaps the value of o to be (apply f current-value-of-atom args)."}, *print-length* {:meta {:file "cljs/core.cljs", :line 119, :column 3, :end-line 119, :end-column 17, :dynamic true, :doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.", :jsdoc ["@type {null|number}"]}, :name cljs.core/*print-length*, :file "cljs/core.cljs", :end-column 17, :column 1, :dynamic true, :line 109, :end-line 119, :doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.", :jsdoc ["@type {null|number}"]}, js-delete {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2066, :column 7, :end-line 2066, :end-column 16, :arglists (quote ([obj key])), :doc "Delete a property from a JavaScript object."}, :name cljs.core/js-delete, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([obj key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2066, :end-line 2066, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj key])), :doc "Delete a property from a JavaScript object."}, truth_ {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 176, :column 7, :end-line 176, :end-column 13, :arglists (quote ([x])), :doc "Internal - do not use!"}, :name cljs.core/truth_, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 176, :end-line 176, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Internal - do not use!"}, array-index-of {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6061, :column 7, :end-line 6061, :end-column 21, :arglists (quote ([arr k]))}, :name cljs.core/array-index-of, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6061, :end-line 6061, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, ->MultiFn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10017, :column 10, :end-line 10017, :end-column 17, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :factory :positional, :arglists (quote ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]))}, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/->MultiFn, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 10017, :end-line 10017, :max-fixed-arity 8, :fn-var true, :arglists (quote ([name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}}, key->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9710, :column 7, :end-line 9710, :end-column 14, :arglists (quote ([k]))}, :name cljs.core/key->js, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9710, :end-line 9710, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, ->MultiStepper {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3882, :column 10, :end-line 3882, :end-column 22, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([xform iters nexts]))}, :protocols #{cljs.core/Object}, :name cljs.core/->MultiStepper, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([xform iters nexts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3882, :end-line 3882, :max-fixed-arity 3, :fn-var true, :arglists (quote ([xform iters nexts])), :skip-protocol-flag nil}, IEncodeJS {:meta {:file "cljs/core.cljs", :line 9703, :column 14, :end-line 9703, :end-column 23, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-clj->js [[x]], -key->js [[x]]}}}, :protocol-symbol true, :name cljs.core/IEncodeJS, :file "cljs/core.cljs", :end-column 23, :column 1, :line 9703, :protocol-info {:methods {-clj->js [[x]], -key->js [[x]]}}, :info nil, :end-line 9703, :impls #{}, :doc nil, :jsdoc ("@interface")}, new-path {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4920, :column 8, :end-line 4920, :end-column 16, :private true, :arglists (quote ([edit level node]))}, :private true, :name cljs.core/new-path, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([edit level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4920, :end-line 4920, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit level node]))}, compare-and-set! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4313, :column 7, :end-line 4313, :end-column 23, :arglists (quote ([a oldval newval])), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false."}, :name cljs.core/compare-and-set!, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([a oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4313, :end-line 4313, :max-fixed-arity 3, :fn-var true, :arglists (quote ([a oldval newval])), :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false."}, array-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1565, :column 7, :end-line 1565, :end-column 16, :arglists (quote ([array] [array i])), :doc "Create a seq from a JavaScript array.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([array] [array i]), :arglists ([array] [array i]), :arglists-meta (nil nil)}}, :name cljs.core/array-seq, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([array] [array i]), :arglists ([array] [array i]), :arglists-meta (nil nil)}, :method-params ([array] [array i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1565, :end-line 1565, :max-fixed-arity 2, :fn-var true, :arglists ([array] [array i]), :doc "Create a seq from a JavaScript array."}, array-copy-downward {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2079, :column 8, :end-line 2079, :end-column 27, :private true, :arglists (quote ([from i to j len]))}, :private true, :name cljs.core/array-copy-downward, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2079, :end-line 2079, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len]))}, pack-array-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6739, :column 8, :end-line 6739, :end-column 23, :private true, :arglists (quote ([array-node edit idx]))}, :private true, :name cljs.core/pack-array-node, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([array-node edit idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6739, :end-line 6739, :max-fixed-arity 3, :fn-var true, :arglists (quote ([array-node edit idx]))}, interleave {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4644, :column 7, :end-line 4644, :end-column 17, :arglists (quote ([c1 c2] [c1 c2 & colls])), :doc "Returns a lazy seq of the first item in each coll, then the second etc.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([c1 c2]), :arglists ([c1 c2] [c1 c2 & colls]), :arglists-meta (nil nil)}}, :name cljs.core/interleave, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([c1 c2]), :arglists ([c1 c2] [c1 c2 & colls]), :arglists-meta (nil nil)}, :method-params ([c1 c2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4644, :end-line 4644, :max-fixed-arity 2, :fn-var true, :arglists ([c1 c2] [c1 c2 & colls]), :doc "Returns a lazy seq of the first item in each coll, then the second etc."}, print-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9374, :column 7, :end-line 9374, :end-column 16, :arglists (quote ([m print-one writer opts]))}, :name cljs.core/print-map, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([m print-one writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9374, :end-line 9374, :max-fixed-arity 4, :fn-var true, :arglists (quote ([m print-one writer opts]))}, ->t_cljs$core7891 {:protocol-inline nil, :meta {:anonymous true, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta7892])), :file "cljs/core.cljs"}, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/->t_cljs$core7891, :variadic false, :file "cljs/core.cljs", :method-params ([meta7892]), :protocol-impl nil, :arglists-meta (nil nil), :anonymous true, :column 3, :factory :positional, :line 3785, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta7892])), :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, map? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2028, :column 16, :end-line 2028, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies IMap"}, :name cljs.core/map?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2028, :ret-tag boolean, :end-line 2028, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IMap"}, m3-C1 {:name cljs.core/m3-C1, :file "cljs/core.cljs", :line 813, :column 1, :end-line 813, :end-column 11, :meta {:file "cljs/core.cljs", :line 813, :column 6, :end-line 813, :end-column 11}}, get {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1816, :column 7, :end-line 1816, :end-column 10, :arglists (quote ([o k] [o k not-found])), :doc "Returns the value mapped to key, not-found or nil if key not present.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}}, :name cljs.core/get, :variadic false, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([o k] [o k not-found]), :arglists ([o k] [o k not-found]), :arglists-meta (nil nil)}, :method-params ([o k] [o k not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1816, :end-line 1816, :max-fixed-arity 3, :fn-var true, :arglists ([o k] [o k not-found]), :doc "Returns the value mapped to key, not-found or nil if key not present."}, identity {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2408, :column 7, :end-line 2408, :end-column 15, :arglists (quote ([x])), :doc "Returns its argument."}, :name cljs.core/identity, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2408, :end-line 2408, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns its argument."}, into {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4764, :column 7, :end-line 4764, :end-column 11, :arglists (quote ([] [to] [to from] [to xform from])), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([] [to] [to from] [to xform from]), :arglists ([] [to] [to from] [to xform from]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/into, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([] [to] [to from] [to xform from]), :arglists ([] [to] [to from] [to xform from]), :arglists-meta (nil nil nil nil)}, :method-params ([] [to] [to from] [to xform from]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 4764, :end-line 4764, :max-fixed-arity 3, :fn-var true, :arglists ([] [to] [to from] [to xform from]), :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied."}, long {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2649, :column 7, :end-line 2649, :end-column 11, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, :name cljs.core/long, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2649, :end-line 2649, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to long by stripping decimal places. Identical to `int'."}, double {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2550, :column 15, :end-line 2550, :end-column 21, :tag number, :arglists (quote ([x]))}, :name cljs.core/double, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2550, :ret-tag number, :end-line 2550, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, volatile? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4350, :column 16, :end-line 4350, :end-column 25, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a volatile."}, :name cljs.core/volatile?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4350, :ret-tag boolean, :end-line 4350, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a volatile."}, ChunkBuffer {:num-fields 2, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/ChunkBuffer, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 3326, :record false, :end-line 3326, :skip-protocol-flag #{cljs.core/ICounted}}, HashSetIter {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/HashSetIter, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 8352, :record false, :end-line 8352, :skip-protocol-flag nil}, -key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 548, :column 4, :end-line 548, :end-column 8, :protocol cljs.core/IMapEntry, :doc "Returns the key of the map entry.", :arglists (quote ([coll]))}, :protocol cljs.core/IMapEntry, :name cljs.core/-key, :variadic false, :file "cljs/core.cljs", :end-column 8, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 546, :end-line 548, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the key of the map entry."}, nfirst {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1647, :column 7, :end-line 1647, :end-column 13, :arglists (quote ([coll])), :doc "Same as (next (first x))"}, :name cljs.core/nfirst, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1647, :end-line 1647, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (first x))"}, StringBufferWriter {:num-fields 1, :protocols #{cljs.core/IWriter}, :name cljs.core/StringBufferWriter, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 774, :record false, :end-line 774, :skip-protocol-flag #{cljs.core/IWriter}}, meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1956, :column 7, :end-line 1956, :end-column 11, :arglists (quote ([o])), :doc "Returns the metadata of obj, returns nil if there is no metadata."}, :name cljs.core/meta, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1956, :end-line 1956, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the metadata of obj, returns nil if there is no metadata."}, tv-editable-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5485, :column 8, :end-line 5485, :end-column 24, :private true, :arglists (quote ([tl]))}, :private true, :name cljs.core/tv-editable-tail, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([tl]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5485, :end-line 5485, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tl]))}, -kv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 602, :column 4, :end-line 602, :end-column 14, :protocol cljs.core/IKVReduce, :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :arglists (quote ([coll f init]))}, :protocol cljs.core/IKVReduce, :name cljs.core/-kv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 599, :end-line 602, :max-fixed-arity 3, :fn-var true, :arglists (quote ([coll f init])), :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments."}, IHash {:meta {:file "cljs/core.cljs", :line 611, :column 14, :end-line 611, :end-column 19, :doc "Protocol for adding hashing functionality to a type.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-hash [[o]]}}}, :protocol-symbol true, :name cljs.core/IHash, :file "cljs/core.cljs", :end-column 19, :column 1, :line 611, :protocol-info {:methods {-hash [[o]]}}, :info nil, :end-line 611, :impls #{cljs.core/Namespace cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/TaggedLiteral default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding hashing functionality to a type.", :jsdoc ("@interface")}, bit-and-not {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2708, :column 7, :end-line 2708, :end-column 18, :arglists (quote ([x y] [x y & more])), :doc "Bitwise and with complement", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-and-not, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2708, :end-line 2708, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise and with complement"}, var? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1080, :column 16, :end-line 1080, :end-column 20, :tag boolean, :arglists (quote ([v])), :doc "Returns true if v is of type cljs.core.Var"}, :name cljs.core/var?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1080, :ret-tag boolean, :end-line 1080, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([v])), :doc "Returns true if v is of type cljs.core.Var"}, -comparator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 649, :column 4, :end-line 649, :end-column 15, :protocol cljs.core/ISorted, :doc "Returns the comparator for coll.", :arglists (quote ([coll]))}, :protocol cljs.core/ISorted, :name cljs.core/-comparator, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 635, :end-line 649, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the comparator for coll."}, unchecked-add-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2565, :column 15, :end-line 2565, :end-column 32, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-add-int, :variadic true, :file "cljs/core.cljs", :end-column 32, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2565, :ret-tag number, :end-line 2565, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0."}, hash-ordered-coll {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1227, :column 15, :end-line 1227, :end-column 32, :tag number, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms."}, :name cljs.core/hash-ordered-coll, :variadic false, :file "cljs/core.cljs", :end-column 32, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1227, :ret-tag number, :end-line 1227, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms."}, extend-object! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2867, :column 8, :end-line 2867, :end-column 22, :private true, :arglists (quote ([obj fn-map])), :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached."}, :private true, :name cljs.core/extend-object!, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([obj fn-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2867, :end-line 2867, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj fn-map])), :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached."}, do-assoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4973, :column 8, :end-line 4973, :end-column 16, :private true, :arglists (quote ([pv level node i val]))}, :private true, :name cljs.core/do-assoc, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([pv level node i val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4973, :end-line 4973, :max-fixed-arity 5, :fn-var true, :arglists (quote ([pv level node i val]))}, reset-meta! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9530, :column 7, :end-line 9530, :end-column 18, :arglists (quote ([iref m])), :doc "Atomically resets the metadata for an atom"}, :name cljs.core/reset-meta!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([iref m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9530, :end-line 9530, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref m])), :doc "Atomically resets the metadata for an atom"}, ->KeySeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8158, :column 10, :end-line 8158, :end-column 16, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([mseq _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->KeySeq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8158, :end-line 8158, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, IEquiv {:meta {:file "cljs/core.cljs", :line 606, :column 14, :end-line 606, :end-column 20, :doc "Protocol for adding value comparison functionality to a type.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-equiv [[o other]]}}}, :protocol-symbol true, :name cljs.core/IEquiv, :file "cljs/core.cljs", :end-column 20, :column 1, :line 606, :protocol-info {:methods {-equiv [[o other]]}}, :info nil, :end-line 606, :impls #{cljs.core/Namespace cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq js/Date cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/Keyword cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/TaggedLiteral number default cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/Atom cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/NeverEquiv cljs.core/LazyTransformer cljs.core/UUID cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding value comparison functionality to a type.", :jsdoc ("@interface")}, tree-map-kv-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7570, :column 8, :end-line 7570, :end-column 26, :private true, :arglists (quote ([node f init]))}, :private true, :name cljs.core/tree-map-kv-reduce, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([node f init]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7570, :end-line 7570, :max-fixed-arity 3, :fn-var true, :arglists (quote ([node f init]))}, cycle {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4611, :column 7, :end-line 4611, :end-column 12, :arglists (quote ([coll])), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll."}, :name cljs.core/cycle, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4611, :end-line 4611, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll."}, t_cljs$core7894 {:num-fields 1, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t_cljs$core7894, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3785, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, -deref {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 575, :column 4, :end-line 575, :end-column 10, :protocol cljs.core/IDeref, :doc "Returns the value of the reference o.", :arglists (quote ([o]))}, :protocol cljs.core/IDeref, :name cljs.core/-deref, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 573, :end-line 575, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the value of the reference o."}, pr-writer-ex-info {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10291, :column 8, :end-line 10291, :end-column 25, :private true, :arglists (quote ([obj writer opts]))}, :private true, :name cljs.core/pr-writer-ex-info, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10291, :end-line 10291, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts]))}, empty? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1992, :column 16, :end-line 1992, :end-column 22, :tag boolean, :arglists (quote ([coll])), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))"}, :name cljs.core/empty?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1992, :ret-tag boolean, :end-line 1992, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([coll])), :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))"}, TaggedLiteral {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/ILookup}, :name cljs.core/TaggedLiteral, :file "cljs/core.cljs", :end-column 23, :type true, :column 10, :line 10384, :record false, :end-line 10384, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/ILookup}}, short {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2548, :column 15, :end-line 2548, :end-column 20, :tag number, :arglists (quote ([x]))}, :name cljs.core/short, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2548, :ret-tag number, :end-line 2548, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, -clj->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9704, :column 4, :end-line 9704, :end-column 12, :protocol cljs.core/IEncodeJS, :doc "Recursively transforms clj values to JavaScript", :arglists (quote ([x]))}, :protocol cljs.core/IEncodeJS, :name cljs.core/-clj->js, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9703, :end-line 9704, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively transforms clj values to JavaScript"}, -chunked-first {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 731, :column 4, :end-line 731, :end-column 18, :protocol cljs.core/IChunkedSeq, :doc "Returns the first chunk in coll.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-first, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 729, :end-line 731, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the first chunk in coll."}, filterv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4796, :column 7, :end-line 4796, :end-column 14, :arglists (quote ([pred coll])), :doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects."}, :name cljs.core/filterv, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4796, :end-line 4796, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects."}, ->TaggedLiteral {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10384, :column 10, :end-line 10384, :end-column 23, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/ILookup}, :factory :positional, :arglists (quote ([tag form]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/ILookup}, :name cljs.core/->TaggedLiteral, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([tag form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 10384, :end-line 10384, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag form])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IPrintWithWriter cljs.core/ILookup}}, tv-editable-root {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5482, :column 8, :end-line 5482, :end-column 24, :private true, :arglists (quote ([node]))}, :private true, :name cljs.core/tv-editable-root, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5482, :end-line 5482, :max-fixed-arity 1, :fn-var true, :arglists (quote ([node]))}, hash {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 889, :column 7, :end-line 889, :end-column 11, :arglists (quote ([o])), :doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =."}, :name cljs.core/hash, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 889, :end-line 889, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =."}, quot {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2678, :column 7, :end-line 2678, :end-column 11, :arglists (quote ([n d])), :doc "quot[ient] of dividing numerator by denominator."}, :name cljs.core/quot, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2678, :end-line 2678, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "quot[ient] of dividing numerator by denominator."}, ns-interns* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10579, :column 7, :end-line 10579, :end-column 18, :arglists (quote ([sym])), :doc "Bootstrap only."}, :name cljs.core/ns-interns*, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10579, :end-line 10579, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym])), :doc "Bootstrap only."}, unchecked-double {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2556, :column 15, :end-line 2556, :end-column 31, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-double, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2556, :ret-tag number, :end-line 2556, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, *target* {:meta {:file "cljs/core.cljs", :line 30, :column 3, :end-line 30, :end-column 11, :dynamic true, :doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.", :declared true}, :name cljs.core/*target*, :file "cljs/core.cljs", :end-column 11, :column 1, :dynamic true, :line 24, :declared true, :end-line 30, :doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option."}, ->ChunkedCons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3375, :column 10, :end-line 3375, :end-column 21, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([chunk more meta __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->ChunkedCons, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([chunk more meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3375, :end-line 3375, :max-fixed-arity 4, :fn-var true, :arglists (quote ([chunk more meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}}, ranged-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5009, :column 7, :end-line 5009, :end-column 22, :arglists (quote ([v start end]))}, :name cljs.core/ranged-iterator, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5009, :end-line 5009, :max-fixed-arity 3, :fn-var true, :arglists (quote ([v start end]))}, ITransientVector {:meta {:file "cljs/core.cljs", :line 706, :column 14, :end-line 706, :end-column 30, :doc "Protocol for adding vector functionality to transient collections.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-assoc-n! [[tcoll n val]], -pop! [[tcoll]]}}}, :protocol-symbol true, :name cljs.core/ITransientVector, :file "cljs/core.cljs", :end-column 30, :column 1, :line 706, :protocol-info {:methods {-assoc-n! [[tcoll n val]], -pop! [[tcoll]]}}, :info nil, :end-line 706, :impls #{cljs.core/TransientVector}, :doc "Protocol for adding vector functionality to transient collections.", :jsdoc ("@interface")}, key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8229, :column 7, :end-line 8229, :end-column 10, :arglists (quote ([map-entry])), :doc "Returns the key of the map entry."}, :name cljs.core/key, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8229, :end-line 8229, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the key of the map entry."}, longs {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2666, :column 7, :end-line 2666, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/longs, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2666, :end-line 2666, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, not= {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3773, :column 16, :end-line 3773, :end-column 20, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Same as (not (= obj1 obj2))", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/not=, :variadic true, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 3773, :ret-tag boolean, :end-line 3773, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Same as (not (= obj1 obj2))"}, set-print-err-fn! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 67, :column 7, :end-line 67, :end-column 24, :arglists (quote ([f])), :doc "Set *print-err-fn* to f."}, :name cljs.core/set-print-err-fn!, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 67, :end-line 67, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Set *print-err-fn* to f."}, string? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 226, :column 16, :end-line 226, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string."}, :name cljs.core/string?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 226, :ret-tag boolean, :end-line 226, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript string."}, es6-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1188, :column 7, :end-line 1188, :end-column 19, :arglists (quote ([coll])), :doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll."}, :name cljs.core/es6-iterator, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1188, :end-line 1188, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll."}, Delay {:num-fields 2, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/Delay, :file "cljs/core.cljs", :end-column 15, :type true, :column 10, :line 9587, :record false, :end-line 9587, :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}}, munge-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10471, :column 8, :end-line 10471, :end-column 17, :private true, :arglists (quote ([name]))}, :private true, :name cljs.core/munge-str, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10471, :end-line 10471, :max-fixed-arity 1, :fn-var true, :arglists (quote ([name]))}, pr-str-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9294, :column 7, :end-line 9294, :end-column 23, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts"}, :name cljs.core/pr-str-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9294, :end-line 9294, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts"}, ->RecordIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5977, :column 10, :end-line 5977, :end-column 20, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([i record base-count fields ext-map-iter]))}, :protocols #{cljs.core/Object}, :name cljs.core/->RecordIter, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([i record base-count fields ext-map-iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5977, :end-line 5977, :max-fixed-arity 5, :fn-var true, :arglists (quote ([i record base-count fields ext-map-iter])), :skip-protocol-flag nil}, m3-C2 {:name cljs.core/m3-C2, :file "cljs/core.cljs", :line 814, :column 1, :end-line 814, :end-column 11, :meta {:file "cljs/core.cljs", :line 814, :column 6, :end-line 814, :end-column 11}}, ->Symbol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 962, :column 10, :end-line 962, :end-column 16, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([ns name str _hash _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}, :name cljs.core/->Symbol, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([ns name str _hash _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 962, :end-line 962, :max-fixed-arity 5, :fn-var true, :arglists (quote ([ns name str _hash _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IMeta cljs.core/IPrintWithWriter cljs.core/IWithMeta}}, *print-newline* {:name cljs.core/*print-newline*, :file "cljs/core.cljs", :line 78, :column 1, :end-line 83, :end-column 18, :dynamic true, :doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects.", :meta {:file "cljs/core.cljs", :line 83, :column 3, :end-line 83, :end-column 18, :dynamic true, :doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects."}}, unchecked-multiply-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2602, :column 15, :end-line 2602, :end-column 37, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-multiply-int, :variadic true, :file "cljs/core.cljs", :end-column 37, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2602, :ret-tag number, :end-line 2602, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1."}, chunk-rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3461, :column 7, :end-line 3461, :end-column 17, :arglists (quote ([s]))}, :name cljs.core/chunk-rest, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3461, :end-line 3461, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, remove-all-methods {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10204, :column 7, :end-line 10204, :end-column 25, :arglists (quote ([multifn])), :doc "Removes all of the methods of multimethod."}, :name cljs.core/remove-all-methods, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10204, :end-line 10204, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Removes all of the methods of multimethod."}, trampoline {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9789, :column 7, :end-line 9789, :end-column 17, :arglists (quote ([f] [f & args])), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & args]), :arglists-meta (nil nil)}}, :name cljs.core/trampoline, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([f]), :arglists ([f] [f & args]), :arglists-meta (nil nil)}, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9789, :end-line 9789, :max-fixed-arity 1, :fn-var true, :arglists ([f] [f & args]), :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns."}, double? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2199, :column 16, :end-line 2199, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true for JavaScript numbers, false otherwise."}, :name cljs.core/double?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2199, :ret-tag boolean, :end-line 2199, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true for JavaScript numbers, false otherwise."}, pr-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 139, :column 8, :end-line 139, :end-column 15, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/pr-opts, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 139, :end-line 139, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, *1 {:name cljs.core/*1, :file "cljs/core.cljs", :line 160, :column 1, :end-line 162, :end-column 5, :doc "bound in a repl thread to the most recent value printed", :meta {:file "cljs/core.cljs", :line 162, :column 3, :end-line 162, :end-column 5, :doc "bound in a repl thread to the most recent value printed"}}, vec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5229, :column 7, :end-line 5229, :end-column 10, :arglists (quote ([coll])), :doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified."}, :name cljs.core/vec, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5229, :end-line 5229, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified."}, *print-meta* {:name cljs.core/*print-meta*, :file "cljs/core.cljs", :line 93, :column 1, :end-line 99, :end-column 15, :dynamic true, :doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.", :meta {:file "cljs/core.cljs", :line 99, :column 3, :end-line 99, :end-column 15, :dynamic true, :doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false."}}, -notify-watches {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 675, :column 4, :end-line 675, :end-column 19, :protocol cljs.core/IWatchable, :doc "Calls all watchers with this, oldval and newval.", :arglists (quote ([this oldval newval]))}, :protocol cljs.core/IWatchable, :name cljs.core/-notify-watches, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([this oldval newval]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 673, :end-line 675, :max-fixed-arity 3, :fn-var true, :arglists (quote ([this oldval newval])), :doc "Calls all watchers with this, oldval and newval."}, MultiFn {:num-fields 8, :protocols #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}, :name cljs.core/MultiFn, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 10017, :record false, :end-line 10017, :skip-protocol-flag #{cljs.core/IHash cljs.core/IFn cljs.core/IMultiFn cljs.core/INamed}}, int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2639, :column 7, :end-line 2639, :end-column 10, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, :name cljs.core/int, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2639, :end-line 2639, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, ->ValSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8234, :column 10, :end-line 8234, :end-column 16, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([mseq _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ValSeq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([mseq _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8234, :end-line 8234, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mseq _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, rand {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9805, :column 7, :end-line 9805, :end-column 11, :arglists (quote ([] [n])), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [n]), :arglists ([] [n]), :arglists-meta (nil nil)}}, :name cljs.core/rand, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [n]), :arglists ([] [n]), :arglists-meta (nil nil)}, :method-params ([] [n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9805, :end-line 9805, :max-fixed-arity 1, :fn-var true, :arglists ([] [n]), :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive)."}, second {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1637, :column 7, :end-line 1637, :end-column 13, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, :name cljs.core/second, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1637, :end-line 1637, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, find-ns-obj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10558, :column 7, :end-line 10558, :end-column 18, :arglists (quote ([ns])), :doc "Bootstrap only."}, :name cljs.core/find-ns-obj, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([ns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10558, :end-line 10558, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns])), :doc "Bootstrap only."}, IEditableCollection {:meta {:file "cljs/core.cljs", :line 683, :column 14, :end-line 683, :end-column 33, :doc "Protocol for collections which can transformed to transients.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-as-transient [[coll]]}}}, :protocol-symbol true, :name cljs.core/IEditableCollection, :file "cljs/core.cljs", :end-column 33, :column 1, :line 683, :protocol-info {:methods {-as-transient [[coll]]}}, :info nil, :end-line 683, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentVector cljs.core/PersistentHashSet}, :doc "Protocol for collections which can transformed to transients.", :jsdoc ("@interface")}, hash-combine {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 925, :column 7, :end-line 925, :end-column 19, :arglists (quote ([seed hash]))}, :name cljs.core/hash-combine, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([seed hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 925, :end-line 925, :max-fixed-arity 2, :fn-var true, :arglists (quote ([seed hash]))}, > {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2496, :column 16, :end-line 2496, :end-column 17, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/>, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2496, :ret-tag boolean, :end-line 2496, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false."}, -name {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 743, :column 12, :end-line 743, :end-column 17, :tag string, :protocol cljs.core/INamed, :doc "Returns the name String of x.", :arglists (quote ([x]))}, :protocol cljs.core/INamed, :name cljs.core/-name, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 741, :ret-tag string, :end-line 743, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x])), :doc "Returns the name String of x."}, replace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8632, :column 7, :end-line 8632, :end-column 14, :arglists (quote ([smap] [smap coll])), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([smap] [smap coll]), :arglists ([smap] [smap coll]), :arglists-meta (nil nil)}}, :name cljs.core/replace, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([smap] [smap coll]), :arglists ([smap] [smap coll]), :arglists-meta (nil nil)}, :method-params ([smap] [smap coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8632, :end-line 8632, :max-fixed-arity 2, :fn-var true, :arglists ([smap] [smap coll]), :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided."}, int? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2141, :column 16, :end-line 2141, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long."}, :name cljs.core/int?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2141, :ret-tag boolean, :end-line 2141, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long."}, ->Subvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5341, :column 10, :end-line 5341, :end-column 16, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta v start end __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->Subvec, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5341, :end-line 5341, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, associative? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2012, :column 16, :end-line 2012, :end-column 28, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll implements Associative"}, :name cljs.core/associative?, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2012, :ret-tag boolean, :end-line 2012, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements Associative"}, unchecked-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2644, :column 7, :end-line 2644, :end-column 20, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, :name cljs.core/unchecked-int, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2644, :end-line 2644, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Coerce to int by stripping decimal places."}, js-keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2059, :column 7, :end-line 2059, :end-column 14, :arglists (quote ([obj])), :doc "Return the JavaScript keys for an object."}, :name cljs.core/js-keys, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2059, :end-line 2059, :max-fixed-arity 1, :fn-var true, :arglists (quote ([obj])), :doc "Return the JavaScript keys for an object."}, inst-ms* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1280, :column 4, :end-line 1280, :end-column 12, :protocol cljs.core/Inst, :doc nil, :arglists (quote ([inst]))}, :protocol cljs.core/Inst, :name cljs.core/inst-ms*, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([inst]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1279, :end-line 1280, :max-fixed-arity 1, :fn-var true, :arglists (quote ([inst])), :doc nil}, ES6EntriesIterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6EntriesIterator, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5990, :record false, :end-line 5990, :skip-protocol-flag nil}, keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3164, :column 16, :end-line 3164, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a Keyword"}, :name cljs.core/keyword?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3164, :ret-tag boolean, :end-line 3164, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a Keyword"}, array-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3812, :column 7, :end-line 3812, :end-column 17, :arglists (quote ([x]))}, :name cljs.core/array-iter, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3812, :end-line 3812, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, force {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9603, :column 7, :end-line 9603, :end-column 12, :arglists (quote ([x])), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"}, :name cljs.core/force, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9603, :end-line 9603, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"}, group-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9822, :column 7, :end-line 9822, :end-column 15, :arglists (quote ([f coll])), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll."}, :name cljs.core/group-by, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9822, :end-line 9822, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f coll])), :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll."}, -rseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 632, :column 9, :end-line 632, :end-column 14, :tag clj, :protocol cljs.core/IReversible, :doc "Returns a seq of the items in coll in reversed order.", :arglists (quote ([coll]))}, :protocol cljs.core/IReversible, :name cljs.core/-rseq, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 630, :ret-tag clj, :end-line 632, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items in coll in reversed order."}, prn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9367, :column 7, :end-line 9367, :end-column 10, :arglists (quote ([& objs])), :doc "Same as pr followed by (newline).", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/prn, :variadic true, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9367, :end-line 9367, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Same as pr followed by (newline)."}, tv-pop-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5502, :column 8, :end-line 5502, :end-column 19, :private true, :arglists (quote ([tv level node]))}, :private true, :name cljs.core/tv-pop-tail, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([tv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5502, :end-line 5502, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tv level node]))}, default-dispatch-val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10233, :column 7, :end-line 10233, :end-column 27, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's default-dispatch-val."}, :name cljs.core/default-dispatch-val, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10233, :end-line 10233, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, return it's default-dispatch-val."}, ->Atom {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4227, :column 10, :end-line 4227, :end-column 14, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}, :factory :positional, :arglists (quote ([state meta validator watches]))}, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/->Atom, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([state meta validator watches]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4227, :end-line 4227, :max-fixed-arity 4, :fn-var true, :arglists (quote ([state meta validator watches])), :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}}, PersistentHashMap {:meta {:file "cljs/core.cljs", :line 6425, :column 27, :end-line 6425, :end-column 44, :declared true}, :num-fields 6, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentHashMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7151, :record false, :declared true, :end-line 7151, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, unchecked-multiply {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2595, :column 15, :end-line 2595, :end-column 33, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the product of nums. (*) returns 1.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-multiply, :variadic true, :file "cljs/core.cljs", :end-column 33, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2595, :ret-tag number, :end-line 2595, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the product of nums. (*) returns 1."}, ArrayNodeSeq {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ArrayNodeSeq, :file "cljs/core.cljs", :end-column 22, :type true, :column 10, :line 7074, :record false, :end-line 7074, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, even? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4058, :column 16, :end-line 4058, :end-column 21, :tag boolean, :arglists (quote ([n])), :doc "Returns true if n is even, throws an exception if n is not an integer"}, :name cljs.core/even?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4058, :ret-tag boolean, :end-line 4058, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is even, throws an exception if n is not an integer"}, es6-iterator-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1205, :column 7, :end-line 1205, :end-column 23, :arglists (quote ([iter])), :doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq."}, :name cljs.core/es6-iterator-seq, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1205, :end-line 1205, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iter])), :doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq."}, unchecked-dec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2572, :column 7, :end-line 2572, :end-column 20, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, :name cljs.core/unchecked-dec, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2572, :end-line 2572, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, Inst {:meta {:file "cljs/core.cljs", :line 1279, :column 14, :end-line 1279, :end-column 18, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {inst-ms* [[inst]]}}}, :protocol-symbol true, :name cljs.core/Inst, :file "cljs/core.cljs", :end-column 18, :column 1, :line 1279, :protocol-info {:methods {inst-ms* [[inst]]}}, :info nil, :end-line 1279, :impls #{js/Date}, :doc nil, :jsdoc ("@interface")}, hash-collision-node-find-index {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6873, :column 8, :end-line 6873, :end-column 38, :private true, :arglists (quote ([arr cnt key]))}, :private true, :name cljs.core/hash-collision-node-find-index, :variadic false, :file "cljs/core.cljs", :end-column 38, :method-params ([arr cnt key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6873, :end-line 6873, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr cnt key]))}, persistent-array-map-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6157, :column 7, :end-line 6157, :end-column 31, :arglists (quote ([arr i _meta]))}, :name cljs.core/persistent-array-map-seq, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6157, :end-line 6157, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta]))}, RangeIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/RangeIterator, :file "cljs/core.cljs", :end-column 23, :type true, :column 10, :line 8815, :record false, :end-line 8815, :skip-protocol-flag nil}, MultiStepper {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/MultiStepper, :file "cljs/core.cljs", :end-column 22, :type true, :column 10, :line 3882, :record false, :end-line 3882, :skip-protocol-flag nil}, tagged-literal? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10414, :column 16, :end-line 10414, :end-column 31, :tag boolean, :arglists (quote ([value])), :doc "Return true if the value is the data representation of a tagged literal"}, :name cljs.core/tagged-literal?, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10414, :ret-tag boolean, :end-line 10414, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([value])), :doc "Return true if the value is the data representation of a tagged literal"}, double-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3536, :column 7, :end-line 3536, :end-column 19, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/double-array, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3536, :end-line 3536, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure."}, create-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10591, :column 7, :end-line 10591, :end-column 16, :arglists (quote ([sym] [sym ns-obj])), :doc "Bootstrap only.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sym] [sym ns-obj]), :arglists ([sym] [sym ns-obj]), :arglists-meta (nil nil)}}, :name cljs.core/create-ns, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sym] [sym ns-obj]), :arglists ([sym] [sym ns-obj]), :arglists-meta (nil nil)}, :method-params ([sym] [sym ns-obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10591, :end-line 10591, :max-fixed-arity 2, :fn-var true, :arglists ([sym] [sym ns-obj]), :doc "Bootstrap only."}, ->EmptyList {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2953, :column 10, :end-line 2953, :end-column 19, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta]))}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->EmptyList, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 2953, :end-line 2953, :max-fixed-arity 1, :fn-var true, :arglists (quote ([meta])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, seq-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2330, :column 8, :end-line 2330, :end-column 18, :private true, :arglists (quote ([f coll] [f val coll])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/seq-reduce, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f val coll]), :arglists ([f coll] [f val coll]), :arglists-meta (nil nil)}, :method-params ([f coll] [f val coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2330, :end-line 2330, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f val coll])}, spread {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3592, :column 7, :end-line 3592, :end-column 13, :arglists (quote ([arglist]))}, :name cljs.core/spread, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([arglist]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3592, :end-line 3592, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arglist]))}, balance-left {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7485, :column 8, :end-line 7485, :end-column 20, :private true, :arglists (quote ([key val ins right]))}, :private true, :name cljs.core/balance-left, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([key val ins right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7485, :end-line 7485, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val ins right]))}, rseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3026, :column 12, :end-line 3026, :end-column 16, :tag seq, :arglists (quote ([rev])), :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil"}, :name cljs.core/rseq, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([rev]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3026, :ret-tag seq, :end-line 3026, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([rev])), :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil"}, ex-cause {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10352, :column 7, :end-line 10352, :end-column 15, :arglists (quote ([ex])), :doc "Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil."}, :name cljs.core/ex-cause, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10352, :end-line 10352, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil."}, IReset {:meta {:file "cljs/core.cljs", :line 751, :column 14, :end-line 751, :end-column 20, :doc "Protocol for adding resetting functionality.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-reset! [[o new-value]]}}}, :protocol-symbol true, :name cljs.core/IReset, :file "cljs/core.cljs", :end-column 20, :column 1, :line 751, :protocol-info {:methods {-reset! [[o new-value]]}}, :info nil, :end-line 751, :impls #{}, :doc "Protocol for adding resetting functionality.", :jsdoc ("@interface")}, IEmptyableCollection {:meta {:file "cljs/core.cljs", :line 481, :column 14, :end-line 481, :end-column 34, :doc "Protocol for creating an empty collection.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-empty [[coll]]}}}, :protocol-symbol true, :name cljs.core/IEmptyableCollection, :file "cljs/core.cljs", :end-column 34, :column 1, :line 481, :protocol-info {:methods {-empty [[coll]]}}, :info nil, :end-line 481, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for creating an empty collection.", :jsdoc ("@interface")}, array-map-index-of {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6075, :column 8, :end-line 6075, :end-column 26, :private true, :arglists (quote ([m k]))}, :private true, :name cljs.core/array-map-index-of, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6075, :end-line 6075, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k]))}, ex-message {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10345, :column 7, :end-line 10345, :end-column 17, :arglists (quote ([ex])), :doc "Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil."}, :name cljs.core/ex-message, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([ex]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10345, :end-line 10345, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ex])), :doc "Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil."}, ->NodeIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6499, :column 11, :end-line 6499, :end-column 23, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i next-entry next-iter]))}, :protocols #{cljs.core/Object}, :name cljs.core/->NodeIterator, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([arr i next-entry next-iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 2, :factory :positional, :line 6499, :end-line 6499, :max-fixed-arity 4, :fn-var true, :arglists (quote ([arr i next-entry next-iter])), :skip-protocol-flag nil}, string-print {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9167, :column 7, :end-line 9167, :end-column 19, :arglists (quote ([x]))}, :name cljs.core/string-print, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9167, :end-line 9167, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, float {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2549, :column 15, :end-line 2549, :end-column 20, :tag number, :arglists (quote ([x]))}, :name cljs.core/float, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2549, :ret-tag number, :end-line 2549, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, fixture2 {:name cljs.core/fixture2, :file "cljs/core.cljs", :line 9583, :column 1, :end-line 9583, :end-column 14, :meta {:file "cljs/core.cljs", :line 9583, :column 6, :end-line 9583, :end-column 14}}, IRecord {:meta {:file "cljs/core.cljs", :line 627, :column 14, :end-line 627, :end-column 21, :doc "Marker interface indicating a record object", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/IRecord, :file "cljs/core.cljs", :end-column 21, :column 1, :line 627, :protocol-info {:methods {}}, :info nil, :end-line 627, :impls #{}, :doc "Marker interface indicating a record object", :jsdoc ("@interface")}, pr-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9325, :column 7, :end-line 9325, :end-column 13, :arglists (quote ([& objs])), :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/pr-str, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9325, :end-line 9325, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter."}, first-array-for-longvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4949, :column 8, :end-line 4949, :end-column 31, :private true, :arglists (quote ([pv]))}, :private true, :name cljs.core/first-array-for-longvec, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([pv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4949, :end-line 4949, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pv]))}, es6-set-entries-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6012, :column 7, :end-line 6012, :end-column 31, :arglists (quote ([coll]))}, :name cljs.core/es6-set-entries-iterator, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6012, :end-line 6012, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, concat {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3600, :column 7, :end-line 3600, :end-column 13, :arglists (quote ([] [x] [x y] [x y & zs])), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & zs]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/concat, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & zs]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 3600, :end-line 3600, :max-fixed-arity 2, :fn-var true, :arglists ([] [x] [x y] [x y & zs]), :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls."}, -methods {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10009, :column 4, :end-line 10009, :end-column 12, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-methods, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10003, :end-line 10009, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, js-reserved {:name cljs.core/js-reserved, :file "cljs/core.cljs", :line 10444, :column 1, :end-line 10446, :end-column 14, :jsdoc ["@type {null|Object}"], :meta {:file "cljs/core.cljs", :line 10446, :column 3, :end-line 10446, :end-column 14, :jsdoc ["@type {null|Object}"]}}, IDerefWithTimeout {:meta {:file "cljs/core.cljs", :line 578, :column 14, :end-line 578, :end-column 31, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-deref-with-timeout [[o msec timeout-val]]}}}, :protocol-symbol true, :name cljs.core/IDerefWithTimeout, :file "cljs/core.cljs", :end-column 31, :column 1, :line 578, :protocol-info {:methods {-deref-with-timeout [[o msec timeout-val]]}}, :info nil, :end-line 578, :impls #{}, :doc nil, :jsdoc ("@interface")}, symbol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 996, :column 7, :end-line 996, :end-column 13, :arglists (quote ([name] [ns name])), :doc "Returns a Symbol with the given namespace and name.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}}, :name cljs.core/symbol, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}, :method-params ([name] [ns name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 996, :end-line 996, :max-fixed-arity 2, :fn-var true, :arglists ([name] [ns name]), :doc "Returns a Symbol with the given namespace and name."}, to-array-2d {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3481, :column 7, :end-line 3481, :end-column 18, :arglists (quote ([coll])), :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll."}, :name cljs.core/to-array-2d, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3481, :end-line 3481, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll."}, Subvec {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/Subvec, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 5341, :record false, :end-line 5341, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, ExceptionInfo {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10303, :column 3, :end-line 10303, :end-column 16, :jsdoc ["@constructor"], :arglists (quote ([message data cause]))}, :name cljs.core/ExceptionInfo, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([message data cause]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10302, :end-line 10303, :max-fixed-arity 3, :fn-var true, :arglists (quote ([message data cause])), :jsdoc ["@constructor"]}, mod {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2673, :column 7, :end-line 2673, :end-column 10, :arglists (quote ([n d])), :doc "Modulus of num and div. Truncates toward negative infinity."}, :name cljs.core/mod, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2673, :end-line 2673, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div. Truncates toward negative infinity."}, ISet {:meta {:file "cljs/core.cljs", :line 553, :column 14, :end-line 553, :end-column 18, :doc "Protocol for adding set functionality to a collection.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-disjoin [[coll v]]}}}, :protocol-symbol true, :name cljs.core/ISet, :file "cljs/core.cljs", :end-column 18, :column 1, :line 553, :protocol-info {:methods {-disjoin [[coll v]]}}, :info nil, :end-line 553, :impls #{cljs.core/PersistentHashSet cljs.core/PersistentTreeSet}, :doc "Protocol for adding set functionality to a collection.", :jsdoc ("@interface")}, pop {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1970, :column 7, :end-line 1970, :end-column 10, :arglists (quote ([coll])), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast."}, :name cljs.core/pop, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1970, :end-line 1970, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast."}, IPending {:meta {:file "cljs/core.cljs", :line 667, :column 14, :end-line 667, :end-column 22, :doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-realized? [[x]]}}}, :protocol-symbol true, :name cljs.core/IPending, :file "cljs/core.cljs", :end-column 22, :column 1, :line 667, :protocol-info {:methods {-realized? [[x]]}}, :info nil, :end-line 667, :impls #{cljs.core/Delay cljs.core/LazySeq}, :doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq.", :jsdoc ("@interface")}, -entry-key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 647, :column 4, :end-line 647, :end-column 14, :protocol cljs.core/ISorted, :doc "Returns the key for entry.", :arglists (quote ([coll entry]))}, :protocol cljs.core/ISorted, :name cljs.core/-entry-key, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 635, :end-line 647, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll entry])), :doc "Returns the key for entry."}, CHAR_MAP {:name cljs.core/CHAR_MAP, :file "cljs/core.cljs", :line 291, :column 1, :end-line 292, :end-column 11, :jsdoc ["@enum {string}"], :meta {:file "cljs/core.cljs", :line 292, :column 3, :end-line 292, :end-column 11, :jsdoc ["@enum {string}"]}}, pop-tail {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4983, :column 8, :end-line 4983, :end-column 16, :private true, :arglists (quote ([pv level node]))}, :private true, :name cljs.core/pop-tail, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([pv level node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4983, :end-line 4983, :max-fixed-arity 3, :fn-var true, :arglists (quote ([pv level node]))}, dissoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3675, :column 7, :end-line 3675, :end-column 14, :arglists (quote ([tcoll key] [tcoll key & ks])), :doc "Returns a transient map that doesn't contain a mapping for key(s).", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll key]), :arglists ([tcoll key] [tcoll key & ks]), :arglists-meta (nil nil)}}, :name cljs.core/dissoc!, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([tcoll key]), :arglists ([tcoll key] [tcoll key & ks]), :arglists-meta (nil nil)}, :method-params ([tcoll key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3675, :end-line 3675, :max-fixed-arity 2, :fn-var true, :arglists ([tcoll key] [tcoll key & ks]), :doc "Returns a transient map that doesn't contain a mapping for key(s)."}, reductions {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9008, :column 7, :end-line 9008, :end-column 17, :arglists (quote ([f coll] [f init coll])), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f init coll]), :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}}, :name cljs.core/reductions, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([f coll] [f init coll]), :arglists ([f coll] [f init coll]), :arglists-meta (nil nil)}, :method-params ([f coll] [f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9008, :end-line 9008, :max-fixed-arity 3, :fn-var true, :arglists ([f coll] [f init coll]), :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init."}, indexed? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1423, :column 16, :end-line 1423, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll implements nth in constant time"}, :name cljs.core/indexed?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1423, :ret-tag boolean, :end-line 1423, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements nth in constant time"}, - {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2449, :column 15, :end-line 2449, :end-column 16, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/-, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2449, :ret-tag number, :end-line 2449, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, -equiv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 608, :column 13, :end-line 608, :end-column 19, :tag boolean, :protocol cljs.core/IEquiv, :doc "Returns true if o and other are equal, false otherwise.", :arglists (quote ([o other]))}, :protocol cljs.core/IEquiv, :name cljs.core/-equiv, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([o other]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 606, :ret-tag boolean, :end-line 608, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([o other])), :doc "Returns true if o and other are equal, false otherwise."}, ->RangeIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8815, :column 10, :end-line 8815, :end-column 23, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([i end step]))}, :protocols #{cljs.core/Object}, :name cljs.core/->RangeIterator, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([i end step]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8815, :end-line 8815, :max-fixed-arity 3, :fn-var true, :arglists (quote ([i end step])), :skip-protocol-flag nil}, ->ArrayNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6772, :column 10, :end-line 6772, :end-column 19, :protocols #{cljs.core/Object cljs.core/IIterable}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([edit cnt arr]))}, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/->ArrayNode, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([edit cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6772, :end-line 6772, :max-fixed-arity 3, :fn-var true, :arglists (quote ([edit cnt arr])), :skip-protocol-flag nil}, assoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3663, :column 7, :end-line 3663, :end-column 13, :arglists (quote ([tcoll key val] [tcoll key val & kvs])), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([tcoll key val]), :arglists ([tcoll key val] [tcoll key val & kvs]), :arglists-meta (nil nil)}}, :name cljs.core/assoc!, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([tcoll key val]), :arglists ([tcoll key val] [tcoll key val & kvs]), :arglists-meta (nil nil)}, :method-params ([tcoll key val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3663, :end-line 3663, :max-fixed-arity 3, :fn-var true, :arglists ([tcoll key val] [tcoll key val & kvs]), :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll."}, hash-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8614, :column 7, :end-line 8614, :end-column 15, :arglists (quote ([] [& keys])), :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keys]), :arglists-meta (nil nil)}}, :name cljs.core/hash-set, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keys]), :arglists-meta (nil nil)}, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8614, :end-line 8614, :max-fixed-arity 0, :fn-var true, :arglists ([] [& keys]), :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj."}, reduce-kv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2396, :column 7, :end-line 2396, :end-column 16, :arglists (quote ([f init coll])), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals."}, :name cljs.core/reduce-kv, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([f init coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2396, :end-line 2396, :max-fixed-arity 3, :fn-var true, :arglists (quote ([f init coll])), :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals."}, reset! {:name cljs.core/reset!, :file "cljs/core.cljs", :line 6438, :column 1, :end-line 6438, :end-column 55, :declared true, :meta {:file "cljs/core.cljs", :line 6438, :column 49, :end-line 6438, :end-column 55, :declared true}}, name {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8683, :column 7, :end-line 8683, :end-column 11, :arglists (quote ([x])), :doc "Returns the name String of a string, symbol or keyword."}, :name cljs.core/name, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8683, :end-line 8683, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns the name String of a string, symbol or keyword."}, ->RedNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7699, :column 10, :end-line 7699, :end-column 17, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([key val left right __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->RedNode, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7699, :end-line 7699, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, unchecked-array-for {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4957, :column 8, :end-line 4957, :end-column 27, :private true, :arglists (quote ([pv i]))}, :private true, :name cljs.core/unchecked-array-for, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4957, :end-line 4957, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i]))}, Fn {:meta {:file "cljs/core.cljs", :line 440, :column 14, :end-line 440, :end-column 16, :doc "Marker protocol", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/Fn, :file "cljs/core.cljs", :end-column 16, :column 1, :line 440, :protocol-info {:methods {}}, :info nil, :end-line 440, :impls #{cljs.core/Var function cljs.core/MetaFn}, :doc "Marker protocol", :jsdoc ("@interface")}, ffirst {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1642, :column 7, :end-line 1642, :end-column 13, :arglists (quote ([coll])), :doc "Same as (first (first x))"}, :name cljs.core/ffirst, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1642, :end-line 1642, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (first x))"}, ->ArrayNodeIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6752, :column 10, :end-line 6752, :end-column 27, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i next-iter]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayNodeIterator, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([arr i next-iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6752, :end-line 6752, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i next-iter])), :skip-protocol-flag nil}, sorted-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8620, :column 7, :end-line 8620, :end-column 17, :arglists (quote ([& keys])), :doc "Returns a new sorted set with supplied keys.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keys)], :arglists ([& keys]), :arglists-meta (nil)}}, :name cljs.core/sorted-set, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keys)], :arglists ([& keys]), :arglists-meta (nil)}, :method-params [(keys)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8620, :end-line 8620, :max-fixed-arity 0, :fn-var true, :arglists ([& keys]), :doc "Returns a new sorted set with supplied keys."}, pr-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9311, :column 8, :end-line 9311, :end-column 20, :private true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts"}, :private true, :name cljs.core/pr-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9311, :end-line 9311, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts"}, PersistentTreeMap {:num-fields 5, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/PersistentTreeMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 7958, :record false, :end-line 7958, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, ->PersistentTreeMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7958, :column 10, :end-line 7958, :end-column 27, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :factory :positional, :arglists (quote ([comp tree cnt meta __hash]))}, :protocols #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentTreeMap, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([comp tree cnt meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7958, :end-line 7958, :max-fixed-arity 5, :fn-var true, :arglists (quote ([comp tree cnt meta __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, array-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1386, :column 8, :end-line 1386, :end-column 20, :private true, :arglists (quote ([arr f] [arr f val] [arr f val idx])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([arr f] [arr f val] [arr f val idx]), :arglists ([arr f] [arr f val] [arr f val idx]), :arglists-meta (nil nil nil)}}, :private true, :name cljs.core/array-reduce, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([arr f] [arr f val] [arr f val idx]), :arglists ([arr f] [arr f val] [arr f val idx]), :arglists-meta (nil nil nil)}, :method-params ([arr f] [arr f val] [arr f val idx]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1386, :end-line 1386, :max-fixed-arity 4, :fn-var true, :arglists ([arr f] [arr f val] [arr f val idx])}, counted? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1419, :column 16, :end-line 1419, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll implements count in constant time"}, :name cljs.core/counted?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1419, :ret-tag boolean, :end-line 1419, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll implements count in constant time"}, tagged-literal {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10419, :column 7, :end-line 10419, :end-column 21, :arglists (quote ([tag form])), :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form."}, :name cljs.core/tagged-literal, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([tag form]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10419, :end-line 10419, :max-fixed-arity 2, :fn-var true, :arglists (quote ([tag form])), :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form."}, println {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9355, :column 7, :end-line 9355, :end-column 14, :arglists (quote ([& objs])), :doc "Same as print followed by (newline)", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/println, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9355, :end-line 9355, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "Same as print followed by (newline)"}, assoc-in {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4846, :column 7, :end-line 4846, :end-column 15, :arglists (quote ([m [k & ks] v])), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created."}, :name cljs.core/assoc-in, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([m p__10202 v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4846, :end-line 4846, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m [k & ks] v])), :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created."}, PersistentHashSet {:num-fields 3, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/PersistentHashSet, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 8362, :record false, :end-line 8362, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, bit-test {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2733, :column 16, :end-line 2733, :end-column 24, :tag boolean, :arglists (quote ([x n])), :doc "Test bit at index n"}, :name cljs.core/bit-test, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2733, :ret-tag boolean, :end-line 2733, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x n])), :doc "Test bit at index n"}, ->Namespace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10526, :column 10, :end-line 10526, :end-column 19, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash}, :factory :positional, :arglists (quote ([obj name]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object}, :name cljs.core/->Namespace, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([obj name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 10526, :end-line 10526, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj name])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash}}, TransientHashMap {:meta {:file "cljs/core.cljs", :line 7137, :column 10, :end-line 7137, :end-column 26, :declared true}, :num-fields 5, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientHashMap, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 7307, :record false, :declared true, :end-line 7307, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, ->PersistentHashMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7151, :column 10, :end-line 7151, :end-column 27, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta cnt root has-nil? nil-val __hash]))}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->PersistentHashMap, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([meta cnt root has-nil? nil-val __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7151, :end-line 7151, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt root has-nil? nil-val __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, array-extend-kv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6078, :column 8, :end-line 6078, :end-column 23, :private true, :arglists (quote ([arr k v]))}, :private true, :name cljs.core/array-extend-kv, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([arr k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6078, :end-line 6078, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr k v]))}, ISwap {:meta {:file "cljs/core.cljs", :line 756, :column 14, :end-line 756, :end-column 19, :doc "Protocol for adding swapping functionality.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-swap! [[o f] [o f a] [o f a b] [o f a b xs]]}}}, :protocol-symbol true, :name cljs.core/ISwap, :file "cljs/core.cljs", :end-column 19, :column 1, :line 756, :protocol-info {:methods {-swap! [[o f] [o f a] [o f a b] [o f a b xs]]}}, :info nil, :end-line 756, :impls #{}, :doc "Protocol for adding swapping functionality.", :jsdoc ("@interface")}, ChunkedCons {:meta {:file "cljs/core.cljs", :line 2044, :column 10, :end-line 2044, :end-column 21, :declared true}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/ChunkedCons, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 3375, :record false, :declared true, :end-line 3375, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta}}, memoize {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9774, :column 7, :end-line 9774, :end-column 14, :arglists (quote ([f])), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use."}, :name cljs.core/memoize, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9774, :end-line 9774, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use."}, alter-meta! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9521, :column 7, :end-line 9521, :end-column 18, :arglists (quote ([iref f & args])), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(iref f args)], :arglists ([iref f & args]), :arglists-meta (nil)}}, :name cljs.core/alter-meta!, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(iref f args)], :arglists ([iref f & args]), :arglists-meta (nil)}, :method-params [(iref f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9521, :end-line 9521, :max-fixed-arity 2, :fn-var true, :arglists ([iref f & args]), :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects"}, ->StringBufferWriter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 774, :column 10, :end-line 774, :end-column 28, :protocols #{cljs.core/IWriter}, :skip-protocol-flag #{cljs.core/IWriter}, :factory :positional, :arglists (quote ([sb]))}, :protocols #{cljs.core/IWriter}, :name cljs.core/->StringBufferWriter, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([sb]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 774, :end-line 774, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sb])), :skip-protocol-flag #{cljs.core/IWriter}}, zero? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2778, :column 16, :end-line 2778, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if num is zero, else false"}, :name cljs.core/zero?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2778, :ret-tag boolean, :end-line 2778, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if num is zero, else false"}, tv-ensure-editable {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5477, :column 8, :end-line 5477, :end-column 26, :private true, :arglists (quote ([edit node]))}, :private true, :name cljs.core/tv-ensure-editable, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([edit node]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5477, :end-line 5477, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit node]))}, simple-keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3214, :column 16, :end-line 3214, :end-column 31, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a keyword without a namespace"}, :name cljs.core/simple-keyword?, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3214, :ret-tag boolean, :end-line 3214, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a keyword without a namespace"}, -indexOf {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1427, :column 8, :end-line 1427, :end-column 16, :private true, :arglists (quote ([coll x] [coll x start])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll x] [coll x start]), :arglists ([coll x] [coll x start]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/-indexOf, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll x] [coll x start]), :arglists ([coll x] [coll x start]), :arglists-meta (nil nil)}, :method-params ([coll x] [coll x start]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1427, :end-line 1427, :max-fixed-arity 3, :fn-var true, :arglists ([coll x] [coll x start])}, *main-cli-fn* {:name cljs.core/*main-cli-fn*, :file "cljs/core.cljs", :line 255, :column 1, :end-line 259, :end-column 16, :doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments", :meta {:file "cljs/core.cljs", :line 259, :column 3, :end-line 259, :end-column 16, :doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments"}}, -assoc-n {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 570, :column 9, :end-line 570, :end-column 17, :tag clj, :protocol cljs.core/IVector, :doc "Returns a new vector with value val added at position n.", :arglists (quote ([coll n val]))}, :protocol cljs.core/IVector, :name cljs.core/-assoc-n, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 568, :ret-tag clj, :end-line 570, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([coll n val])), :doc "Returns a new vector with value val added at position n."}, unchecked-dec-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2577, :column 7, :end-line 2577, :end-column 24, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, :name cljs.core/unchecked-dec-int, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2577, :end-line 2577, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one less than x, an int."}, hash-imap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2846, :column 8, :end-line 2846, :end-column 17, :private true, :arglists (quote ([m]))}, :private true, :name cljs.core/hash-imap, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2846, :end-line 2846, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m]))}, dominates {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9974, :column 8, :end-line 9974, :end-column 17, :private true, :arglists (quote ([x y prefer-table hierarchy]))}, :private true, :name cljs.core/dominates, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x y prefer-table hierarchy]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9974, :end-line 9974, :max-fixed-arity 4, :fn-var true, :arglists (quote ([x y prefer-table hierarchy]))}, persistent! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3643, :column 7, :end-line 3643, :end-column 18, :arglists (quote ([tcoll])), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception."}, :name cljs.core/persistent!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3643, :end-line 3643, :max-fixed-arity 1, :fn-var true, :arglists (quote ([tcoll])), :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception."}, set-print-fn! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 63, :column 7, :end-line 63, :end-column 20, :arglists (quote ([f])), :doc "Set *print-fn* to f."}, :name cljs.core/set-print-fn!, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 63, :end-line 63, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Set *print-fn* to f."}, nnext {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1657, :column 7, :end-line 1657, :end-column 12, :arglists (quote ([coll])), :doc "Same as (next (next x))"}, :name cljs.core/nnext, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1657, :end-line 1657, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (next (next x))"}, Box {:num-fields 1, :protocols #{}, :name cljs.core/Box, :file "cljs/core.cljs", :end-column 13, :type true, :column 10, :line 6436, :record false, :end-line 6436, :skip-protocol-flag nil}, balance-right {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7510, :column 8, :end-line 7510, :end-column 21, :private true, :arglists (quote ([key val left ins]))}, :private true, :name cljs.core/balance-right, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([key val left ins]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7510, :end-line 7510, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left ins]))}, throw-no-method-error {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10014, :column 8, :end-line 10014, :end-column 29, :private true, :arglists (quote ([name dispatch-val]))}, :private true, :name cljs.core/throw-no-method-error, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([name dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10014, :end-line 10014, :max-fixed-arity 2, :fn-var true, :arglists (quote ([name dispatch-val]))}, demunge-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10493, :column 8, :end-line 10493, :end-column 19, :private true, :arglists (quote ([munged-name]))}, :private true, :name cljs.core/demunge-str, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([munged-name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10493, :end-line 10493, :max-fixed-arity 1, :fn-var true, :arglists (quote ([munged-name]))}, add-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9535, :column 7, :end-line 9535, :end-column 16, :arglists (quote ([iref key f])), :doc "Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1"}, :name cljs.core/add-watch, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([iref key f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9535, :end-line 9535, :max-fixed-arity 3, :fn-var true, :arglists (quote ([iref key f])), :doc "Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1"}, not-every? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4039, :column 16, :end-line 4039, :end-column 26, :tag boolean, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true."}, :name cljs.core/not-every?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4039, :ret-tag boolean, :end-line 4039, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true."}, rem {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2684, :column 7, :end-line 2684, :end-column 10, :arglists (quote ([n d])), :doc "remainder of dividing numerator by denominator."}, :name cljs.core/rem, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2684, :end-line 2684, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "remainder of dividing numerator by denominator."}, pr-sb-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9287, :column 8, :end-line 9287, :end-column 23, :private true, :arglists (quote ([objs opts]))}, :private true, :name cljs.core/pr-sb-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9287, :end-line 9287, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts]))}, ->HashMapIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7139, :column 10, :end-line 7139, :end-column 21, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([nil-val root-iter seen]))}, :protocols #{cljs.core/Object}, :name cljs.core/->HashMapIter, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([nil-val root-iter seen]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7139, :end-line 7139, :max-fixed-arity 3, :fn-var true, :arglists (quote ([nil-val root-iter seen])), :skip-protocol-flag nil}, BitmapIndexedNode {:num-fields 3, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/BitmapIndexedNode, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6537, :record false, :end-line 6537, :skip-protocol-flag nil}, ->NodeSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7002, :column 10, :end-line 7002, :end-column 17, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta nodes i s __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->NodeSeq, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7002, :end-line 7002, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, some {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4044, :column 7, :end-line 4044, :end-column 11, :arglists (quote ([pred coll])), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)"}, :name cljs.core/some, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4044, :end-line 4044, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)"}, INamed {:meta {:file "cljs/core.cljs", :line 741, :column 14, :end-line 741, :end-column 20, :doc "Protocol for adding a name.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-name [[x]], -namespace [[x]]}}}, :protocol-symbol true, :name cljs.core/INamed, :file "cljs/core.cljs", :end-column 20, :column 1, :line 741, :protocol-info {:methods {-name [[x]], -namespace [[x]]}}, :info nil, :end-line 741, :impls #{cljs.core/MultiFn cljs.core/Keyword cljs.core/Symbol}, :doc "Protocol for adding a name.", :jsdoc ("@interface")}, ->Box {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6436, :column 10, :end-line 6436, :end-column 13, :protocols #{}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([val]))}, :protocols #{}, :name cljs.core/->Box, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6436, :end-line 6436, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag nil}, IReduce {:meta {:file "cljs/core.cljs", :line 591, :column 14, :end-line 591, :end-column 21, :doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-reduce [[coll f] [coll f start]]}}}, :protocol-symbol true, :name cljs.core/IReduce, :file "cljs/core.cljs", :end-column 21, :column 1, :line 591, :protocol-info {:methods {-reduce [[coll f] [coll f start]]}}, :info nil, :end-line 591, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ArrayChunk cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.", :jsdoc ("@interface")}, neg-int? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2165, :column 16, :end-line 2165, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is positive."}, :name cljs.core/neg-int?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2165, :ret-tag boolean, :end-line 2165, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is positive."}, drop {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4547, :column 7, :end-line 4547, :end-column 11, :arglists (quote ([n] [n coll])), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}}, :name cljs.core/drop, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([n] [n coll]), :arglists ([n] [n coll]), :arglists-meta (nil nil)}, :method-params ([n] [n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4547, :end-line 4547, :max-fixed-arity 2, :fn-var true, :arglists ([n] [n coll]), :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided."}, NodeIterator {:num-fields 4, :protocols #{cljs.core/Object}, :name cljs.core/NodeIterator, :file "cljs/core.cljs", :end-column 23, :type true, :column 11, :line 6499, :record false, :end-line 6499, :skip-protocol-flag nil}, js-obj {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2051, :column 7, :end-line 2051, :end-column 13, :arglists (quote ([] [& keyvals])), :doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keyvals]), :arglists-meta (nil nil)}}, :name cljs.core/js-obj, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 0, :method-params ([]), :arglists ([] [& keyvals]), :arglists-meta (nil nil)}, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2051, :end-line 2051, :max-fixed-arity 0, :fn-var true, :arglists ([] [& keyvals]), :doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values."}, ITransientCollection {:meta {:file "cljs/core.cljs", :line 688, :column 14, :end-line 688, :end-column 34, :doc "Protocol for adding basic functionality to transient collections.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-conj! [[tcoll val]], -persistent! [[tcoll]]}}}, :protocol-symbol true, :name cljs.core/ITransientCollection, :file "cljs/core.cljs", :end-column 34, :column 1, :line 688, :protocol-info {:methods {-conj! [[tcoll val]], -persistent! [[tcoll]]}}, :info nil, :end-line 688, :impls #{cljs.core/TransientVector cljs.core/TransientHashMap cljs.core/TransientArrayMap cljs.core/TransientHashSet}, :doc "Protocol for adding basic functionality to transient collections.", :jsdoc ("@interface")}, Atom {:num-fields 4, :protocols #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IMeta cljs.core/IDeref}, :name cljs.core/Atom, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 4227, :record false, :end-line 4227, :skip-protocol-flag #{cljs.core/IWatchable cljs.core/IAtom cljs.core/IEquiv cljs.core/IHash cljs.core/IMeta cljs.core/IDeref}}, nth {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1742, :column 7, :end-line 1742, :end-column 10, :arglists (quote ([coll n] [coll n not-found])), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}}, :name cljs.core/nth, :variadic false, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll n] [coll n not-found]), :arglists ([coll n] [coll n not-found]), :arglists-meta (nil nil)}, :method-params ([coll n] [coll n not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1742, :end-line 1742, :max-fixed-arity 3, :fn-var true, :arglists ([coll n] [coll n not-found]), :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences."}, sorted? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2020, :column 16, :end-line 2020, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISorted"}, :name cljs.core/sorted?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2020, :ret-tag boolean, :end-line 2020, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies ISorted"}, nil? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 190, :column 16, :end-line 190, :end-column 20, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is nil, false otherwise."}, :name cljs.core/nil?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 190, :ret-tag boolean, :end-line 190, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is nil, false otherwise."}, split-at {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4617, :column 7, :end-line 4617, :end-column 15, :arglists (quote ([n coll])), :doc "Returns a vector of [(take n coll) (drop n coll)]"}, :name cljs.core/split-at, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4617, :end-line 4617, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "Returns a vector of [(take n coll) (drop n coll)]"}, TransientHashSet {:meta {:file "cljs/core.cljs", :line 8350, :column 10, :end-line 8350, :end-column 26, :declared true}, :num-fields 1, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/TransientHashSet, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 8461, :record false, :declared true, :end-line 8461, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}}, *e {:name cljs.core/*e, :file "cljs/core.cljs", :line 172, :column 1, :end-line 174, :end-column 5, :doc "bound in a repl thread to the most recent exception caught by the repl", :meta {:file "cljs/core.cljs", :line 174, :column 3, :end-line 174, :end-column 5, :doc "bound in a repl thread to the most recent exception caught by the repl"}}, array-map-extend-kv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6089, :column 8, :end-line 6089, :end-column 27, :private true, :arglists (quote ([m k v]))}, :private true, :name cljs.core/array-map-extend-kv, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([m k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6089, :end-line 6089, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m k v]))}, prn-str-with-opts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9302, :column 7, :end-line 9302, :end-column 24, :arglists (quote ([objs opts])), :doc "Same as pr-str-with-opts followed by (newline)"}, :name cljs.core/prn-str-with-opts, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([objs opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9302, :end-line 9302, :max-fixed-arity 2, :fn-var true, :arglists (quote ([objs opts])), :doc "Same as pr-str-with-opts followed by (newline)"}, not-native {:name cljs.core/not-native, :file "cljs/core.cljs", :line 181, :column 1, :end-line 181, :end-column 16, :meta {:file "cljs/core.cljs", :line 181, :column 6, :end-line 181, :end-column 16}}, random-sample {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9653, :column 7, :end-line 9653, :end-column 20, :arglists (quote ([prob] [prob coll])), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prob] [prob coll]), :arglists ([prob] [prob coll]), :arglists-meta (nil nil)}}, :name cljs.core/random-sample, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([prob] [prob coll]), :arglists ([prob] [prob coll]), :arglists-meta (nil nil)}, :method-params ([prob] [prob coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9653, :end-line 9653, :max-fixed-arity 2, :fn-var true, :arglists ([prob] [prob coll]), :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided."}, select-keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8334, :column 7, :end-line 8334, :end-column 18, :arglists (quote ([map keyseq])), :doc "Returns a map containing only those entries in map whose key is in keys"}, :name cljs.core/select-keys, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([map keyseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8334, :end-line 8334, :max-fixed-arity 2, :fn-var true, :arglists (quote ([map keyseq])), :doc "Returns a map containing only those entries in map whose key is in keys"}, bit-and {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2696, :column 7, :end-line 2696, :end-column 14, :arglists (quote ([x y] [x y & more])), :doc "Bitwise and", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-and, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2696, :end-line 2696, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise and"}, bounded-count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3580, :column 7, :end-line 3580, :end-column 20, :arglists (quote ([n coll])), :doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq", :added "1.9"}, :added "1.9", :name cljs.core/bounded-count, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([n coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3580, :end-line 3580, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n coll])), :doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq"}, update {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4882, :column 7, :end-line 4882, :end-column 13, :arglists (quote ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more])), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z]), :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/update, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z]), :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :arglists-meta (nil nil nil nil nil)}, :method-params ([m k f] [m k f x] [m k f x y] [m k f x y z]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 4882, :end-line 4882, :max-fixed-arity 6, :fn-var true, :arglists ([m k f] [m k f x] [m k f x y] [m k f x y z] [m k f x y z & more]), :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value."}, gensym_counter {:name cljs.core/gensym_counter, :file "cljs/core.cljs", :line 9566, :column 1, :end-line 9568, :end-column 17, :jsdoc ["@type {*}"], :meta {:file "cljs/core.cljs", :line 9568, :column 3, :end-line 9568, :end-column 17, :jsdoc ["@type {*}"]}}, find-macros-ns {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10612, :column 7, :end-line 10612, :end-column 21, :arglists (quote ([ns])), :doc "Bootstrap only."}, :name cljs.core/find-macros-ns, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([ns]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10612, :end-line 10612, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns])), :doc "Bootstrap only."}, list* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3625, :column 7, :end-line 3625, :end-column 12, :arglists (quote ([args] [a args] [a b args] [a b c args] [a b c d & more])), :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([args] [a args] [a b args] [a b c args]), :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/list*, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([args] [a args] [a b args] [a b c args]), :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :arglists-meta (nil nil nil nil nil)}, :method-params ([args] [a args] [a b args] [a b c args]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 3625, :end-line 3625, :max-fixed-arity 4, :fn-var true, :arglists ([args] [a args] [a b args] [a b c args] [a b c d & more]), :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence."}, array-index-of-keyword? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6025, :column 8, :end-line 6025, :end-column 31, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-keyword?, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6025, :end-line 6025, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, ->Keyword {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3136, :column 10, :end-line 3136, :end-column 17, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}, :factory :positional, :arglists (quote ([ns name fqn _hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/->Keyword, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([ns name fqn _hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3136, :end-line 3136, :max-fixed-arity 4, :fn-var true, :arglists (quote ([ns name fqn _hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}}, update-in {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4855, :column 7, :end-line 4855, :end-column 16, :arglists (quote ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args])), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c]), :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/update-in, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 6, :method-params ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c]), :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]), :arglists-meta (nil nil nil nil nil)}, :method-params ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 4855, :end-line 4855, :max-fixed-arity 6, :fn-var true, :arglists ([m [k & ks] f] [m [k & ks] f a] [m [k & ks] f a b] [m [k & ks] f a b c] [m [k & ks] f a b c & args]), :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created."}, prefer-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10214, :column 7, :end-line 10214, :end-column 20, :arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict"}, :name cljs.core/prefer-method, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([multifn dispatch-val-x dispatch-val-y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10214, :end-line 10214, :max-fixed-arity 3, :fn-var true, :arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict"}, hash-symbol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 943, :column 8, :end-line 943, :end-column 19, :private true, :arglists (quote ([sym]))}, :private true, :name cljs.core/hash-symbol, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 943, :end-line 943, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym]))}, ensure-reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1333, :column 7, :end-line 1333, :end-column 21, :arglists (quote ([x])), :doc "If x is already reduced?, returns it, else returns (reduced x)"}, :name cljs.core/ensure-reduced, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1333, :end-line 1333, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is already reduced?, returns it, else returns (reduced x)"}, edit-and-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6470, :column 8, :end-line 6470, :end-column 20, :private true, :arglists (quote ([inode edit i a] [inode edit i a j b])), :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([inode edit i a] [inode edit i a j b]), :arglists ([inode edit i a] [inode edit i a j b]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/edit-and-set, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 6, :method-params ([inode edit i a] [inode edit i a j b]), :arglists ([inode edit i a] [inode edit i a j b]), :arglists-meta (nil nil)}, :method-params ([inode edit i a] [inode edit i a j b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6470, :end-line 6470, :max-fixed-arity 6, :fn-var true, :arglists ([inode edit i a] [inode edit i a j b])}, ->PersistentArrayMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6172, :column 10, :end-line 6172, :end-column 28, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta cnt arr __hash]))}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentArrayMap, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([meta cnt arr __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6172, :end-line 6172, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta cnt arr __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}}, instance? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 932, :column 16, :end-line 932, :end-column 25, :tag boolean, :arglists (quote ([c x])), :doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false"}, :name cljs.core/instance?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([c x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 932, :ret-tag boolean, :end-line 932, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([c x])), :doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false"}, mix-collection-hash {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1215, :column 15, :end-line 1215, :end-column 34, :tag number, :arglists (quote ([hash-basis count])), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms."}, :name cljs.core/mix-collection-hash, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([hash-basis count]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1215, :ret-tag number, :end-line 1215, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([hash-basis count])), :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms."}, re-find {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9106, :column 7, :end-line 9106, :end-column 14, :arglists (quote ([re s])), :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups."}, :name cljs.core/re-find, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9106, :end-line 9106, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups."}, run! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9696, :column 7, :end-line 9696, :end-column 11, :arglists (quote ([proc coll])), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil"}, :name cljs.core/run!, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([proc coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9696, :end-line 9696, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proc coll])), :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil"}, char-escapes {:name cljs.core/char-escapes, :file "cljs/core.cljs", :line 9174, :column 1, :end-line 9174, :end-column 28, :private true, :meta {:file "cljs/core.cljs", :line 9174, :column 16, :end-line 9174, :end-column 28, :private true}}, ES6Iterator {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ES6Iterator, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 1179, :record false, :end-line 1179, :skip-protocol-flag nil}, val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8305, :column 7, :end-line 8305, :end-column 10, :arglists (quote ([map-entry])), :doc "Returns the value in the map entry."}, :name cljs.core/val, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([map-entry]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8305, :end-line 8305, :max-fixed-arity 1, :fn-var true, :arglists (quote ([map-entry])), :doc "Returns the value in the map entry."}, unchecked-add {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2558, :column 15, :end-line 2558, :end-column 28, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/unchecked-add, :variadic true, :file "cljs/core.cljs", :end-column 28, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2558, :ret-tag number, :end-line 2558, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0."}, not {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 207, :column 16, :end-line 207, :end-column 19, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is logical false, false otherwise."}, :name cljs.core/not, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 207, :ret-tag boolean, :end-line 207, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is logical false, false otherwise."}, -vreset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 763, :column 4, :end-line 763, :end-column 12, :protocol cljs.core/IVolatile, :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :arglists (quote ([o new-value]))}, :protocol cljs.core/IVolatile, :name cljs.core/-vreset!, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 761, :end-line 763, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value."}, fn->comparator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2289, :column 17, :end-line 2289, :end-column 31, :private true, :arglists (quote ([f])), :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator."}, :private true, :name cljs.core/fn->comparator, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2289, :end-line 2289, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator."}, with-meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1947, :column 7, :end-line 1947, :end-column 16, :arglists (quote ([o meta])), :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata."}, :name cljs.core/with-meta, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([o meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1947, :end-line 1947, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o meta])), :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata."}, unreduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1338, :column 7, :end-line 1338, :end-column 16, :arglists (quote ([x])), :doc "If x is reduced?, returns (deref x), else returns x"}, :name cljs.core/unreduced, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1338, :end-line 1338, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "If x is reduced?, returns (deref x), else returns x"}, record? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2035, :column 16, :end-line 2035, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies IRecord"}, :name cljs.core/record?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2035, :ret-tag boolean, :end-line 2035, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies IRecord"}, type {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 261, :column 7, :end-line 261, :end-column 11, :arglists (quote ([x])), :doc "Return x's constructor."}, :name cljs.core/type, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 261, :end-line 261, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Return x's constructor."}, identical? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 185, :column 16, :end-line 185, :end-column 26, :tag boolean, :arglists (quote ([x y])), :doc "Tests if 2 arguments are the same object"}, :name cljs.core/identical?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 185, :ret-tag boolean, :end-line 185, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([x y])), :doc "Tests if 2 arguments are the same object"}, -namespace {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 745, :column 12, :end-line 745, :end-column 22, :tag string, :protocol cljs.core/INamed, :doc "Returns the namespace String of x.", :arglists (quote ([x]))}, :protocol cljs.core/INamed, :name cljs.core/-namespace, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 741, :ret-tag string, :end-line 745, :max-fixed-arity 1, :tag string, :fn-var true, :arglists (quote ([x])), :doc "Returns the namespace String of x."}, unchecked-divide-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2582, :column 15, :end-line 2582, :end-column 35, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/unchecked-divide-int, :variadic true, :file "cljs/core.cljs", :end-column 35, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2582, :ret-tag number, :end-line 2582, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators."}, ns-name {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10630, :column 7, :end-line 10630, :end-column 14, :arglists (quote ([ns-obj])), :doc "Bootstrap only."}, :name cljs.core/ns-name, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ns-obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10630, :end-line 10630, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ns-obj])), :doc "Bootstrap only."}, swap-global-hierarchy! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9848, :column 8, :end-line 9848, :end-column 30, :private true, :arglists (quote ([f & args])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}}, :private true, :name cljs.core/swap-global-hierarchy!, :variadic true, :file "cljs/core.cljs", :end-column 30, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(f args)], :arglists ([f & args]), :arglists-meta (nil)}, :method-params [(f args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9848, :end-line 9848, :max-fixed-arity 1, :fn-var true, :arglists ([f & args])}, max-key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8704, :column 7, :end-line 8704, :end-column 14, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is greatest.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/max-key, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}, :method-params ([k x] [k x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 8704, :end-line 8704, :max-fixed-arity 3, :fn-var true, :arglists ([k x] [k x y] [k x y & more]), :doc "Returns the x for which (k x), a number, is greatest."}, ->PersistentTreeSet {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8498, :column 10, :end-line 8498, :end-column 27, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta tree-map __hash]))}, :protocols #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}, :name cljs.core/->PersistentTreeSet, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([meta tree-map __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8498, :end-line 8498, :max-fixed-arity 3, :fn-var true, :arglists (quote ([meta tree-map __hash])), :skip-protocol-flag #{cljs.core/IReversible cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/ISet cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/ILookup}}, *out* {:name cljs.core/*out*, :file "cljs/core.cljs", :line 38, :column 1, :end-line 41, :end-column 8, :dynamic true, :jsdoc ["@type {*}"], :meta {:file "cljs/core.cljs", :line 41, :column 3, :end-line 41, :end-column 8, :dynamic true, :jsdoc ["@type {*}"]}}, ->ChunkBuffer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3326, :column 10, :end-line 3326, :end-column 21, :protocols #{cljs.core/Object cljs.core/ICounted}, :skip-protocol-flag #{cljs.core/ICounted}, :factory :positional, :arglists (quote ([buf end]))}, :protocols #{cljs.core/Object cljs.core/ICounted}, :name cljs.core/->ChunkBuffer, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([buf end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3326, :end-line 3326, :max-fixed-arity 2, :fn-var true, :arglists (quote ([buf end])), :skip-protocol-flag #{cljs.core/ICounted}}, hash-string {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 878, :column 7, :end-line 878, :end-column 18, :arglists (quote ([k]))}, :name cljs.core/hash-string, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 878, :end-line 878, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, ValSeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/ValSeq, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 8234, :record false, :end-line 8234, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -prefers {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10010, :column 4, :end-line 10010, :end-column 12, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-prefers, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10003, :end-line 10010, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, set-validator! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4322, :column 7, :end-line 4322, :end-column 21, :arglists (quote ([iref val])), :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed."}, :name cljs.core/set-validator!, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([iref val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4322, :end-line 4322, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref val])), :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed."}, ident? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3194, :column 16, :end-line 3194, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword"}, :name cljs.core/ident?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3194, :ret-tag boolean, :end-line 3194, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword"}, -meta {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 583, :column 16, :end-line 583, :end-column 21, :tag clj-or-nil, :protocol cljs.core/IMeta, :doc "Returns the metadata of object o.", :arglists (quote ([o]))}, :protocol cljs.core/IMeta, :name cljs.core/-meta, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 581, :ret-tag clj-or-nil, :end-line 583, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :doc "Returns the metadata of object o."}, RedNode {:meta {:file "cljs/core.cljs", :line 7483, :column 10, :end-line 7483, :end-column 17, :declared true}, :num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/RedNode, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 7699, :record false, :declared true, :end-line 7699, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, -dispatch-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10012, :column 4, :end-line 10012, :end-column 16, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-dispatch-fn, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10003, :end-line 10012, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, ->IndexedSeqIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1461, :column 10, :end-line 1461, :end-column 28, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i]))}, :protocols #{cljs.core/Object}, :name cljs.core/->IndexedSeqIterator, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1461, :end-line 1461, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil}, -add-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10005, :column 4, :end-line 10005, :end-column 15, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val method]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-add-method, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([mf dispatch-val method]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10003, :end-line 10005, :max-fixed-arity 3, :fn-var true, :arglists (quote ([mf dispatch-val method])), :doc nil}, balance-left-del {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7532, :column 8, :end-line 7532, :end-column 24, :private true, :arglists (quote ([key val del right]))}, :private true, :name cljs.core/balance-left-del, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([key val del right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7532, :end-line 7532, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val del right]))}, swap! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4291, :column 7, :end-line 4291, :end-column 12, :arglists (quote ([a f] [a f x] [a f x y] [a f x y & more])), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([a f] [a f x] [a f x y]), :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/swap!, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([a f] [a f x] [a f x y]), :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([a f] [a f x] [a f x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 4291, :end-line 4291, :max-fixed-arity 4, :fn-var true, :arglists ([a f] [a f x] [a f x y] [a f x y & more]), :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in."}, vals {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8299, :column 7, :end-line 8299, :end-column 11, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's values."}, :name cljs.core/vals, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([hash-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8299, :end-line 8299, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's values."}, -chunked-next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 738, :column 4, :end-line 738, :end-column 17, :protocol cljs.core/IChunkedNext, :doc "Returns a new collection of coll without the first chunk.", :arglists (quote ([coll]))}, :protocol cljs.core/IChunkedNext, :name cljs.core/-chunked-next, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 736, :end-line 738, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first chunk."}, unchecked-subtract {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2620, :column 15, :end-line 2620, :end-column 33, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/unchecked-subtract, :variadic true, :file "cljs/core.cljs", :end-column 33, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2620, :ret-tag number, :end-line 2620, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result."}, remove-pair {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6458, :column 8, :end-line 6458, :end-column 19, :private true, :arglists (quote ([arr i]))}, :private true, :name cljs.core/remove-pair, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6458, :end-line 6458, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i]))}, IMap {:meta {:file "cljs/core.cljs", :line 540, :column 14, :end-line 540, :end-column 18, :doc "Protocol for adding mapping functionality to collections.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-dissoc [[coll k]]}}}, :protocol-symbol true, :name cljs.core/IMap, :file "cljs/core.cljs", :end-column 18, :column 1, :line 540, :protocol-info {:methods {-dissoc [[coll k]]}}, :info nil, :end-line 540, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/PersistentTreeMap}, :doc "Protocol for adding mapping functionality to collections.", :jsdoc ("@interface")}, ->SeqIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3818, :column 10, :end-line 3818, :end-column 17, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([_seq _next]))}, :protocols #{cljs.core/Object}, :name cljs.core/->SeqIter, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([_seq _next]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3818, :end-line 3818, :max-fixed-arity 2, :fn-var true, :arglists (quote ([_seq _next])), :skip-protocol-flag nil}, sorted-set-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8625, :column 7, :end-line 8625, :end-column 20, :arglists (quote ([comparator & keys])), :doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keys)], :arglists ([comparator & keys]), :arglists-meta (nil)}}, :name cljs.core/sorted-set-by, :variadic true, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keys)], :arglists ([comparator & keys]), :arglists-meta (nil)}, :method-params [(comparator keys)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8625, :end-line 8625, :max-fixed-arity 1, :fn-var true, :arglists ([comparator & keys]), :doc "Returns a new sorted set with supplied keys, using the supplied comparator."}, PersistentVector {:num-fields 6, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentVector, :file "cljs/core.cljs", :end-column 26, :type true, :column 10, :line 5019, :record false, :end-line 5019, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, cloneable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1099, :column 16, :end-line 1099, :end-column 26, :tag boolean, :arglists (quote ([value])), :doc "Return true if x implements ICloneable protocol."}, :name cljs.core/cloneable?, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1099, :ret-tag boolean, :end-line 1099, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([value])), :doc "Return true if x implements ICloneable protocol."}, qualified-ident? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3202, :column 16, :end-line 3202, :end-column 32, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword with a namespace"}, :name cljs.core/qualified-ident?, :variadic false, :file "cljs/core.cljs", :end-column 32, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3202, :ret-tag boolean, :end-line 3202, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword with a namespace"}, hash-string* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 861, :column 7, :end-line 861, :end-column 19, :arglists (quote ([s]))}, :name cljs.core/hash-string*, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 861, :end-line 861, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, key-test {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6440, :column 16, :end-line 6440, :end-column 24, :tag boolean, :arglists (quote ([key other]))}, :name cljs.core/key-test, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([key other]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6440, :ret-tag boolean, :end-line 6440, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([key other]))}, ->LazyTransformer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3927, :column 10, :end-line 3927, :end-column 25, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([stepper first rest meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->LazyTransformer, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([stepper first rest meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3927, :end-line 3927, :max-fixed-arity 4, :fn-var true, :arglists (quote ([stepper first rest meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, -reset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10004, :column 4, :end-line 10004, :end-column 10, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-reset, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([mf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10003, :end-line 10004, :max-fixed-arity 1, :fn-var true, :arglists (quote ([mf])), :doc nil}, true? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2095, :column 16, :end-line 2095, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is the value true, false otherwise."}, :name cljs.core/true?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2095, :ret-tag boolean, :end-line 2095, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value true, false otherwise."}, find-ns-obj* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10550, :column 8, :end-line 10550, :end-column 20, :private true, :arglists (quote ([ctxt xs])), :doc "Bootstrap only."}, :private true, :name cljs.core/find-ns-obj*, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([ctxt xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10550, :end-line 10550, :max-fixed-arity 2, :fn-var true, :arglists (quote ([ctxt xs])), :doc "Bootstrap only."}, array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 391, :column 14, :end-line 391, :end-column 19, :tag array, :arglists (quote ([var-args])), :doc "Creates a new javascript array.\n@param {...*} var_args"}, :name cljs.core/array, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([var-args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 391, :ret-tag array, :end-line 391, :max-fixed-arity 1, :tag array, :fn-var true, :arglists (quote ([var-args])), :doc "Creates a new javascript array.\n@param {...*} var_args"}, print {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9346, :column 3, :end-line 9346, :end-column 8, :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption."}, :name cljs.core/print, :variadic true, :file "cljs/core.cljs", :end-column 8, :method-params ([objs]), :protocol-impl nil, :arglists-meta (), :column 1, :line 9343, :end-line 9346, :max-fixed-arity 0, :fn-var true, :arglists nil, :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption."}, -peek {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 562, :column 4, :end-line 562, :end-column 9, :protocol cljs.core/IStack, :doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :arglists (quote ([coll]))}, :protocol cljs.core/IStack, :name cljs.core/-peek, :variadic false, :file "cljs/core.cljs", :end-column 9, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 558, :end-line 562, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the item from the top of the stack. Is used by cljs.core/peek."}, ISeq {:meta {:file "cljs/core.cljs", :line 507, :column 14, :end-line 507, :end-column 18, :doc "Protocol for collections to provide access to their items as sequences.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-first [[coll]], -rest [[coll]]}}}, :protocol-symbol true, :name cljs.core/ISeq, :file "cljs/core.cljs", :end-column 18, :column 1, :line 507, :protocol-info {:methods {-first [[coll]], -rest [[coll]]}}, :info nil, :end-line 507, :impls #{cljs.core/Cons cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/LazySeq cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq}, :doc "Protocol for collections to provide access to their items as sequences.", :jsdoc ("@interface")}, empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1689, :column 7, :end-line 1689, :end-column 12, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll, or nil"}, :name cljs.core/empty, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1689, :end-line 1689, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns an empty collection of the same category as coll, or nil"}, remove-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10209, :column 7, :end-line 10209, :end-column 20, :arglists (quote ([multifn dispatch-val])), :doc "Removes the method of multimethod associated with dispatch-value."}, :name cljs.core/remove-method, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10209, :end-line 10209, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Removes the method of multimethod associated with dispatch-value."}, PersistentQueueSeq {:num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueueSeq, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 5680, :record false, :end-line 5680, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, balance-right-del {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7551, :column 8, :end-line 7551, :end-column 25, :private true, :arglists (quote ([key val left del]))}, :private true, :name cljs.core/balance-right-del, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([key val left del]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7551, :end-line 7551, :max-fixed-arity 4, :fn-var true, :arglists (quote ([key val left del]))}, volatile! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4345, :column 7, :end-line 4345, :end-column 16, :arglists (quote ([val])), :doc "Creates and returns a Volatile with an initial value of val."}, :name cljs.core/volatile!, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4345, :end-line 4345, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :doc "Creates and returns a Volatile with an initial value of val."}, / {:protocol-inline nil, :meta {:tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :file "cljs/core.cljs"}, :name cljs.core//, :variadic true, :file "cljs/core.cljs", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2465, :ret-tag number, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators."}, bitpos {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6467, :column 8, :end-line 6467, :end-column 14, :private true, :arglists (quote ([hash shift]))}, :private true, :name cljs.core/bitpos, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([hash shift]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6467, :end-line 6467, :max-fixed-arity 2, :fn-var true, :arglists (quote ([hash shift]))}, bit-or {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2702, :column 7, :end-line 2702, :end-column 13, :arglists (quote ([x y] [x y & more])), :doc "Bitwise or", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}}, :name cljs.core/bit-or, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x y]), :arglists ([x y] [x y & more]), :arglists-meta (nil nil)}, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2702, :end-line 2702, :max-fixed-arity 2, :fn-var true, :arglists ([x y] [x y & more]), :doc "Bitwise or"}, m3-fmix {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 822, :column 15, :end-line 822, :end-column 22, :tag number, :arglists (quote ([h1 len]))}, :name cljs.core/m3-fmix, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([h1 len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 822, :ret-tag number, :end-line 822, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([h1 len]))}, vector {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5240, :column 7, :end-line 5240, :end-column 13, :arglists (quote ([& args])), :doc "Creates a new vector containing the args.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}}, :name cljs.core/vector, :variadic true, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}, :method-params [(args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 5240, :end-line 5240, :max-fixed-arity 0, :fn-var true, :arglists ([& args]), :doc "Creates a new vector containing the args."}, hash-coll {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2836, :column 8, :end-line 2836, :end-column 17, :private true, :arglists (quote ([coll]))}, :private true, :name cljs.core/hash-coll, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2836, :end-line 2836, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, clone-and-set {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6449, :column 8, :end-line 6449, :end-column 21, :private true, :arglists (quote ([arr i a] [arr i a j b])), :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([arr i a] [arr i a j b]), :arglists ([arr i a] [arr i a j b]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/clone-and-set, :variadic false, :file "cljs/core.cljs", :end-column 21, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([arr i a] [arr i a j b]), :arglists ([arr i a] [arr i a j b]), :arglists-meta (nil nil)}, :method-params ([arr i a] [arr i a j b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6449, :end-line 6449, :max-fixed-arity 5, :fn-var true, :arglists ([arr i a] [arr i a j b])}, array->transient-hash-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6427, :column 8, :end-line 6427, :end-column 33, :private true, :arglists (quote ([len arr]))}, :private true, :name cljs.core/array->transient-hash-map, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([len arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6427, :end-line 6427, :max-fixed-arity 2, :fn-var true, :arglists (quote ([len arr]))}, >= {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2508, :column 16, :end-line 2508, :end-column 18, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/>=, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2508, :ret-tag boolean, :end-line 2508, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false."}, ->TransientHashSet {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8461, :column 10, :end-line 8461, :end-column 26, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :factory :positional, :arglists (quote ([transient-map]))}, :protocols #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}, :name cljs.core/->TransientHashSet, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([transient-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8461, :end-line 8461, :max-fixed-arity 1, :fn-var true, :arglists (quote ([transient-map])), :skip-protocol-flag #{cljs.core/ITransientSet cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ILookup}}, drop-last {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4572, :column 7, :end-line 4572, :end-column 16, :arglists (quote ([s] [n s])), :doc "Return a lazy sequence of all but the last n (default 1) items in coll", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([s] [n s]), :arglists ([s] [n s]), :arglists-meta (nil nil)}}, :name cljs.core/drop-last, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([s] [n s]), :arglists ([s] [n s]), :arglists-meta (nil nil)}, :method-params ([s] [n s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4572, :end-line 4572, :max-fixed-arity 2, :fn-var true, :arglists ([s] [n s]), :doc "Return a lazy sequence of all but the last n (default 1) items in coll"}, ->ArrayIter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3803, :column 10, :end-line 3803, :end-column 19, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([arr i]))}, :protocols #{cljs.core/Object}, :name cljs.core/->ArrayIter, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([arr i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3803, :end-line 3803, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr i])), :skip-protocol-flag nil}, object? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 219, :column 16, :end-line 219, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x's constructor is Object"}, :name cljs.core/object?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 219, :ret-tag boolean, :end-line 219, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x's constructor is Object"}, ->ArrayNodeSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7074, :column 10, :end-line 7074, :end-column 22, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta nodes i s __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ArrayNodeSeq, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([meta nodes i s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7074, :end-line 7074, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta nodes i s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, t_cljs$core7891 {:num-fields 1, :protocols #{cljs.core/Object cljs.core/IMeta cljs.core/IWithMeta}, :name cljs.core/t_cljs$core7891, :file "cljs/core.cljs", :type true, :anonymous true, :column 3, :line 3785, :record false, :skip-protocol-flag #{cljs.core/IMeta cljs.core/IWithMeta}}, tree-map-append {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7870, :column 8, :end-line 7870, :end-column 23, :private true, :arglists (quote ([left right]))}, :private true, :name cljs.core/tree-map-append, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([left right]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7870, :end-line 7870, :max-fixed-arity 2, :fn-var true, :arglists (quote ([left right]))}, not-empty {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3780, :column 7, :end-line 3780, :end-column 16, :arglists (quote ([coll])), :doc "If coll is empty, returns nil, else coll"}, :name cljs.core/not-empty, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3780, :end-line 3780, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "If coll is empty, returns nil, else coll"}, distinct {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8649, :column 7, :end-line 8649, :end-column 15, :arglists (quote ([] [coll])), :doc "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}}, :name cljs.core/distinct, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [coll]), :arglists ([] [coll]), :arglists-meta (nil nil)}, :method-params ([] [coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8649, :end-line 8649, :max-fixed-arity 1, :fn-var true, :arglists ([] [coll]), :doc "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided."}, partition {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4805, :column 7, :end-line 4805, :end-column 16, :arglists (quote ([n coll] [n step coll] [n step pad coll])), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([n coll] [n step coll] [n step pad coll]), :arglists ([n coll] [n step coll] [n step pad coll]), :arglists-meta (nil nil nil)}}, :name cljs.core/partition, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([n coll] [n step coll] [n step pad coll]), :arglists ([n coll] [n step coll] [n step pad coll]), :arglists-meta (nil nil nil)}, :method-params ([n coll] [n step coll] [n step pad coll]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 4805, :end-line 4805, :max-fixed-arity 4, :fn-var true, :arglists ([n coll] [n step coll] [n step pad coll]), :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items."}, IMultiFn {:meta {:file "cljs/core.cljs", :line 10003, :column 14, :end-line 10003, :end-column 22, :doc nil, :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-prefer-method [[mf dispatch-val dispatch-val-y]], -default-dispatch-val [[mf]], -remove-method [[mf dispatch-val]], -methods [[mf]], -prefers [[mf]], -dispatch-fn [[mf]], -add-method [[mf dispatch-val method]], -reset [[mf]], -get-method [[mf dispatch-val]]}}}, :protocol-symbol true, :name cljs.core/IMultiFn, :file "cljs/core.cljs", :end-column 22, :column 1, :line 10003, :protocol-info {:methods {-prefer-method [[mf dispatch-val dispatch-val-y]], -default-dispatch-val [[mf]], -remove-method [[mf dispatch-val]], -methods [[mf]], -prefers [[mf]], -dispatch-fn [[mf]], -add-method [[mf dispatch-val method]], -reset [[mf]], -get-method [[mf dispatch-val]]}}, :info nil, :end-line 10003, :impls #{cljs.core/MultiFn}, :doc nil, :jsdoc ("@interface")}, DEMUNGE_PATTERN {:name cljs.core/DEMUNGE_PATTERN, :file "cljs/core.cljs", :line 345, :column 1, :end-line 345, :end-column 21, :meta {:file "cljs/core.cljs", :line 345, :column 6, :end-line 345, :end-column 21}}, fix {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2634, :column 16, :end-line 2634, :end-column 19, :tag number, :private true, :arglists (quote ([q]))}, :private true, :name cljs.core/fix, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([q]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2634, :ret-tag number, :end-line 2634, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([q]))}, EmptyList {:num-fields 1, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/EmptyList, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 2953, :record false, :end-line 2953, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, HashMapIter {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/HashMapIter, :file "cljs/core.cljs", :end-column 21, :type true, :column 10, :line 7139, :record false, :end-line 7139, :skip-protocol-flag nil}, IAssociative {:meta {:file "cljs/core.cljs", :line 531, :column 14, :end-line 531, :end-column 26, :doc "Protocol for adding associativity to collections.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-contains-key? [[coll k]], -assoc [[coll k v]]}}}, :protocol-symbol true, :name cljs.core/IAssociative, :file "cljs/core.cljs", :end-column 26, :column 1, :line 531, :protocol-info {:methods {-contains-key? [[coll k]], -assoc [[coll k v]]}}, :info nil, :end-line 531, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/PersistentArrayMap cljs.core/BlackNode cljs.core/Subvec cljs.core/PersistentVector cljs.core/PersistentTreeMap cljs.core/RedNode}, :doc "Protocol for adding associativity to collections.", :jsdoc ("@interface")}, bit-flip {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2719, :column 7, :end-line 2719, :end-column 15, :arglists (quote ([x n])), :doc "Flip bit at index n"}, :name cljs.core/bit-flip, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2719, :end-line 2719, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Flip bit at index n"}, long-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3514, :column 7, :end-line 3514, :end-column 17, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/long-array, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3514, :end-line 3514, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure."}, descendants {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9887, :column 7, :end-line 9887, :end-column 18, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}}, :name cljs.core/descendants, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9887, :end-line 9887, :max-fixed-arity 2, :fn-var true, :arglists ([tag] [h tag]), :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships."}, imul {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 801, :column 17, :end-line 801, :end-column 21, :tag number, :arglists (quote ([a b]))}, :name cljs.core/imul, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 3, :line 801, :ret-tag number, :end-line 801, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([a b]))}, ->Delay {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9587, :column 10, :end-line 9587, :end-column 15, :protocols #{cljs.core/IPending cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}, :factory :positional, :arglists (quote ([f value]))}, :protocols #{cljs.core/IPending cljs.core/IDeref}, :name cljs.core/->Delay, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([f value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 9587, :end-line 9587, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f value])), :skip-protocol-flag #{cljs.core/IPending cljs.core/IDeref}}, array-for {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4968, :column 8, :end-line 4968, :end-column 17, :private true, :arglists (quote ([pv i]))}, :private true, :name cljs.core/array-for, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pv i]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4968, :end-line 4968, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pv i]))}, merge {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8310, :column 7, :end-line 8310, :end-column 12, :arglists (quote ([& maps])), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(maps)], :arglists ([& maps]), :arglists-meta (nil)}}, :name cljs.core/merge, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(maps)], :arglists ([& maps]), :arglists-meta (nil)}, :method-params [(maps)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8310, :end-line 8310, :max-fixed-arity 0, :fn-var true, :arglists ([& maps]), :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result."}, ISeqable {:meta {:file "cljs/core.cljs", :line 616, :column 14, :end-line 616, :end-column 22, :doc "Protocol for adding the ability to a type to be transformed into a sequence.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-seq [[o]]}}}, :protocol-symbol true, :name cljs.core/ISeqable, :file "cljs/core.cljs", :end-column 22, :column 1, :line 616, :protocol-info {:methods {-seq [[o]]}}, :info nil, :end-line 616, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/Eduction cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/ES6IteratorSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding the ability to a type to be transformed into a sequence.", :jsdoc ("@interface")}, js-mod {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2668, :column 7, :end-line 2668, :end-column 13, :arglists (quote ([n d])), :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"}, :name cljs.core/js-mod, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([n d]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2668, :end-line 2668, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n d])), :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"}, integer? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2133, :column 16, :end-line 2133, :end-column 24, :tag boolean, :arglists (quote ([n])), :doc "Returns true if n is a JavaScript number with no decimal part."}, :name cljs.core/integer?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2133, :ret-tag boolean, :end-line 2133, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is a JavaScript number with no decimal part."}, MetaFn {:num-fields 2, :protocols #{cljs.core/IFn cljs.core/IMeta cljs.core/Fn cljs.core/IWithMeta}, :name cljs.core/MetaFn, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 1894, :record false, :end-line 1894, :skip-protocol-flag #{cljs.core/IFn cljs.core/IMeta cljs.core/IWithMeta}}, NS_CACHE {:name cljs.core/NS_CACHE, :file "cljs/core.cljs", :line 10546, :column 1, :end-line 10548, :end-column 11, :doc "Bootstrap only.", :jsdoc ["@type {*}"], :meta {:file "cljs/core.cljs", :line 10548, :column 3, :end-line 10548, :end-column 11, :doc "Bootstrap only.", :jsdoc ["@type {*}"]}}, mapv {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4780, :column 7, :end-line 4780, :end-column 11, :arglists (quote ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/mapv, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f coll] [f c1 c2] [f c1 c2 c3]), :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :arglists-meta (nil nil nil nil)}, :method-params ([f coll] [f c1 c2] [f c1 c2 c3]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 4780, :end-line 4780, :max-fixed-arity 4, :fn-var true, :arglists ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls]), :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments."}, infinite? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2204, :column 16, :end-line 2204, :end-column 25, :tag boolean, :arglists (quote ([x])), :doc "Returns true for Infinity and -Infinity values."}, :name cljs.core/infinite?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2204, :ret-tag boolean, :end-line 2204, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true for Infinity and -Infinity values."}, partition-all {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8729, :column 7, :end-line 8729, :end-column 20, :arglists (quote ([n] [n coll] [n step coll])), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([n] [n coll] [n step coll]), :arglists ([n] [n coll] [n step coll]), :arglists-meta (nil nil nil)}}, :name cljs.core/partition-all, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([n] [n coll] [n step coll]), :arglists ([n] [n coll] [n step coll]), :arglists-meta (nil nil nil)}, :method-params ([n] [n coll] [n step coll]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 8729, :end-line 8729, :max-fixed-arity 3, :fn-var true, :arglists ([n] [n coll] [n step coll]), :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided."}, partition-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8958, :column 7, :end-line 8958, :end-column 19, :arglists (quote ([f] [f coll])), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}}, :name cljs.core/partition-by, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f coll]), :arglists ([f] [f coll]), :arglists-meta (nil nil)}, :method-params ([f] [f coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8958, :end-line 8958, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f coll]), :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided."}, ISequential {:meta {:file "cljs/core.cljs", :line 621, :column 14, :end-line 621, :end-column 25, :doc "Marker interface indicating a persistent collection of sequential items", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/ISequential, :file "cljs/core.cljs", :end-column 25, :column 1, :line 621, :protocol-info {:methods {}}, :info nil, :end-line 621, :impls #{cljs.core/Cons cljs.core/Eduction cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Marker interface indicating a persistent collection of sequential items", :jsdoc ("@interface")}, ->LazySeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3246, :column 10, :end-line 3246, :end-column 17, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta fn s __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->LazySeq, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([meta fn s __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3246, :end-line 3246, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta fn s __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IPending cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, equiv-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5807, :column 8, :end-line 5807, :end-column 17, :private true, :arglists (quote ([x y])), :doc "Assumes y is a map. Returns true if x equals y, otherwise returns\n  false."}, :private true, :name cljs.core/equiv-map, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5807, :end-line 5807, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes y is a map. Returns true if x equals y, otherwise returns\n  false."}, ->Volatile {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4337, :column 10, :end-line 4337, :end-column 18, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IDeref}, :factory :positional, :arglists (quote ([state]))}, :protocols #{cljs.core/IVolatile cljs.core/IDeref}, :name cljs.core/->Volatile, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([state]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4337, :end-line 4337, :max-fixed-arity 1, :fn-var true, :arglists (quote ([state])), :skip-protocol-flag #{cljs.core/IDeref}}, object-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3558, :column 7, :end-line 3558, :end-column 19, :arglists (quote ([size-or-seq] [size init-val-or-seq])), :doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}}, :name cljs.core/object-array, :variadic false, :file "cljs/core.cljs", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([size-or-seq] [size init-val-or-seq]), :arglists ([size-or-seq] [size init-val-or-seq]), :arglists-meta (nil nil)}, :method-params ([size-or-seq] [size init-val-or-seq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3558, :end-line 3558, :max-fixed-arity 2, :fn-var true, :arglists ([size-or-seq] [size init-val-or-seq]), :doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure."}, Keyword {:meta {:file "cljs/core.cljs", :line 183, :column 20, :end-line 183, :end-column 27, :declared true}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/INamed cljs.core/IPrintWithWriter}, :name cljs.core/Keyword, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 3136, :record false, :declared true, :end-line 3136, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/INamed cljs.core/IPrintWithWriter}}, derive {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9896, :column 7, :end-line 9896, :end-column 13, :arglists (quote ([tag parent] [h tag parent])), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}}, :name cljs.core/derive, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9896, :end-line 9896, :max-fixed-arity 3, :fn-var true, :arglists ([tag parent] [h tag parent]), :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."}, seq-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3836, :column 7, :end-line 3836, :end-column 15, :arglists (quote ([coll]))}, :name cljs.core/seq-iter, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3836, :end-line 3836, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, IChunkedSeq {:meta {:file "cljs/core.cljs", :line 729, :column 14, :end-line 729, :end-column 25, :doc "Protocol for accessing a collection as sequential chunks.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-chunked-first [[coll]], -chunked-rest [[coll]]}}}, :protocol-symbol true, :name cljs.core/IChunkedSeq, :file "cljs/core.cljs", :end-column 25, :column 1, :line 729, :protocol-info {:methods {-chunked-first [[coll]], -chunked-rest [[coll]]}}, :info nil, :end-line 729, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Protocol for accessing a collection as sequential chunks.", :jsdoc ("@interface")}, special-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10366, :column 16, :end-line 10366, :end-column 31, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x names a special form"}, :name cljs.core/special-symbol?, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10366, :ret-tag boolean, :end-line 10366, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x names a special form"}, compare-keywords {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3124, :column 8, :end-line 3124, :end-column 24, :private true, :arglists (quote ([a b]))}, :private true, :name cljs.core/compare-keywords, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3124, :end-line 3124, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, ancestors {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9879, :column 7, :end-line 9879, :end-column 16, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}}, :name cljs.core/ancestors, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9879, :end-line 9879, :max-fixed-arity 2, :fn-var true, :arglists ([tag] [h tag]), :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"}, subseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8785, :column 7, :end-line 8785, :end-column 13, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}}, :name cljs.core/subseq, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8785, :end-line 8785, :max-fixed-arity 5, :fn-var true, :arglists ([sc test key] [sc start-test start-key end-test end-key]), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"}, LazyTransformer {:meta {:file "cljs/core.cljs", :line 3848, :column 10, :end-line 3848, :end-column 25, :declared true}, :num-fields 4, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/LazyTransformer, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 3927, :record false, :declared true, :end-line 3927, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta}}, gensym {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9570, :column 7, :end-line 9570, :end-column 13, :arglists (quote ([] [prefix-string])), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [prefix-string]), :arglists ([] [prefix-string]), :arglists-meta (nil nil)}}, :name cljs.core/gensym, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 1, :method-params ([] [prefix-string]), :arglists ([] [prefix-string]), :arglists-meta (nil nil)}, :method-params ([] [prefix-string]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9570, :end-line 9570, :max-fixed-arity 1, :fn-var true, :arglists ([] [prefix-string]), :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'."}, -next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 519, :column 16, :end-line 519, :end-column 21, :tag clj-or-nil, :protocol cljs.core/INext, :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :arglists (quote ([coll]))}, :protocol cljs.core/INext, :name cljs.core/-next, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 517, :ret-tag clj-or-nil, :end-line 519, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil"}, ->HashCollisionNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6882, :column 10, :end-line 6882, :end-column 27, :protocols #{cljs.core/Object cljs.core/IIterable}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([edit collision-hash cnt arr]))}, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/->HashCollisionNode, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([edit collision-hash cnt arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6882, :end-line 6882, :max-fixed-arity 4, :fn-var true, :arglists (quote ([edit collision-hash cnt arr])), :skip-protocol-flag nil}, delay? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9599, :column 16, :end-line 9599, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "returns true if x is a Delay created with delay"}, :name cljs.core/delay?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9599, :ret-tag boolean, :end-line 9599, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "returns true if x is a Delay created with delay"}, create-inode-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7057, :column 8, :end-line 7057, :end-column 24, :private true, :arglists (quote ([nodes] [nodes i s])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([nodes] [nodes i s]), :arglists ([nodes] [nodes i s]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/create-inode-seq, :variadic false, :file "cljs/core.cljs", :end-column 24, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([nodes] [nodes i s]), :arglists ([nodes] [nodes i s]), :arglists-meta (nil nil)}, :method-params ([nodes] [nodes i s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7057, :end-line 7057, :max-fixed-arity 3, :fn-var true, :arglists ([nodes] [nodes i s])}, flatten {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4756, :column 7, :end-line 4756, :end-column 14, :arglists (quote ([x])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil."}, :name cljs.core/flatten, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4756, :end-line 4756, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil."}, -dissoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 543, :column 9, :end-line 543, :end-column 16, :tag clj, :protocol cljs.core/IMap, :doc "Returns a new collection of coll without the mapping for key k.", :arglists (quote ([coll k]))}, :protocol cljs.core/IMap, :name cljs.core/-dissoc, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 540, :ret-tag clj, :end-line 543, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll k])), :doc "Returns a new collection of coll without the mapping for key k."}, doubles {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2665, :column 7, :end-line 2665, :end-column 14, :arglists (quote ([x]))}, :name cljs.core/doubles, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2665, :end-line 2665, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -contains-key? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 533, :column 13, :end-line 533, :end-column 27, :tag boolean, :protocol cljs.core/IAssociative, :doc "Returns true if k is a key in coll.", :arglists (quote ([coll k]))}, :protocol cljs.core/IAssociative, :name cljs.core/-contains-key?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([coll k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 531, :ret-tag boolean, :end-line 533, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([coll k])), :doc "Returns true if k is a key in coll."}, remove-watch {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9558, :column 7, :end-line 9558, :end-column 19, :arglists (quote ([iref key])), :doc "Removes a watch (set by add-watch) from a reference"}, :name cljs.core/remove-watch, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([iref key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9558, :end-line 9558, :max-fixed-arity 2, :fn-var true, :arglists (quote ([iref key])), :doc "Removes a watch (set by add-watch) from a reference"}, ex-info {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10331, :column 7, :end-line 10331, :end-column 14, :arglists (quote ([msg data] [msg data cause])), :doc "Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([msg data] [msg data cause]), :arglists ([msg data] [msg data cause]), :arglists-meta (nil nil)}}, :name cljs.core/ex-info, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([msg data] [msg data cause]), :arglists ([msg data] [msg data cause]), :arglists-meta (nil nil)}, :method-params ([msg data] [msg data cause]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10331, :end-line 10331, :max-fixed-arity 3, :fn-var true, :arglists ([msg data] [msg data cause]), :doc "Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data."}, ifn? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2128, :column 16, :end-line 2128, :end-column 20, :tag boolean, :arglists (quote ([f])), :doc "Returns true if f returns true for fn? or satisfies IFn."}, :name cljs.core/ifn?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2128, :ret-tag boolean, :end-line 2128, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Returns true if f returns true for fn? or satisfies IFn."}, IAtom {:meta {:file "cljs/core.cljs", :line 748, :column 14, :end-line 748, :end-column 19, :doc "Marker protocol indicating an atom.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/IAtom, :file "cljs/core.cljs", :end-column 19, :column 1, :line 748, :protocol-info {:methods {}}, :info nil, :end-line 748, :impls #{cljs.core/Atom}, :doc "Marker protocol indicating an atom.", :jsdoc ("@interface")}, ->PersistentQueue {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5728, :column 10, :end-line 5728, :end-column 25, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([meta count front rear __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/->PersistentQueue, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([meta count front rear __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5728, :end-line 5728, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta count front rear __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}}, nat-int? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2179, :column 16, :end-line 2179, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is a natural integer value."}, :name cljs.core/nat-int?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2179, :ret-tag boolean, :end-line 2179, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is a natural integer value."}, IWatchable {:meta {:file "cljs/core.cljs", :line 673, :column 14, :end-line 673, :end-column 24, :doc "Protocol for types that can be watched. Currently only implemented by Atom.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-notify-watches [[this oldval newval]], -add-watch [[this key f]], -remove-watch [[this key]]}}}, :protocol-symbol true, :name cljs.core/IWatchable, :file "cljs/core.cljs", :end-column 24, :column 1, :line 673, :protocol-info {:methods {-notify-watches [[this oldval newval]], -add-watch [[this key f]], -remove-watch [[this key]]}}, :info nil, :end-line 673, :impls #{cljs.core/Atom}, :doc "Protocol for types that can be watched. Currently only implemented by Atom.", :jsdoc ("@interface")}, ->Stepper {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3853, :column 10, :end-line 3853, :end-column 17, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([xform iter]))}, :protocols #{cljs.core/Object}, :name cljs.core/->Stepper, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([xform iter]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3853, :end-line 3853, :max-fixed-arity 2, :fn-var true, :arglists (quote ([xform iter])), :skip-protocol-flag nil}, pv-fresh-node {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4902, :column 8, :end-line 4902, :end-column 21, :private true, :arglists (quote ([edit]))}, :private true, :name cljs.core/pv-fresh-node, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([edit]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4902, :end-line 4902, :max-fixed-arity 1, :fn-var true, :arglists (quote ([edit]))}, subvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5466, :column 7, :end-line 5466, :end-column 13, :arglists (quote ([v start] [v start end])), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([v start] [v start end]), :arglists ([v start] [v start end]), :arglists-meta (nil nil)}}, :name cljs.core/subvec, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([v start] [v start end]), :arglists ([v start] [v start end]), :arglists-meta (nil nil)}, :method-params ([v start] [v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5466, :end-line 5466, :max-fixed-arity 3, :fn-var true, :arglists ([v start] [v start end]), :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done."}, -pop! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 710, :column 9, :end-line 710, :end-column 14, :tag clj, :protocol cljs.core/ITransientVector, :doc "Returns tcoll with the last item removed from it.", :arglists (quote ([tcoll]))}, :protocol cljs.core/ITransientVector, :name cljs.core/-pop!, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([tcoll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 706, :ret-tag clj, :end-line 710, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([tcoll])), :doc "Returns tcoll with the last item removed from it."}, partial {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4111, :column 7, :end-line 4111, :end-column 14, :arglists (quote ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more])), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3]), :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/partial, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 4, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3]), :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :arglists-meta (nil nil nil nil nil)}, :method-params ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 4111, :end-line 4111, :max-fixed-arity 4, :fn-var true, :arglists ([f] [f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more]), :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args."}, chunked-seq? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2046, :column 16, :end-line 2046, :end-column 28, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is satisfies IChunkedSeq."}, :name cljs.core/chunked-seq?, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2046, :ret-tag boolean, :end-line 2046, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is satisfies IChunkedSeq."}, replicate {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4627, :column 7, :end-line 4627, :end-column 16, :arglists (quote ([n x])), :doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs."}, :name cljs.core/replicate, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([n x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4627, :end-line 4627, :max-fixed-arity 2, :fn-var true, :arglists (quote ([n x])), :doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs."}, PersistentQueue {:num-fields 5, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta}, :name cljs.core/PersistentQueue, :file "cljs/core.cljs", :end-column 25, :type true, :column 10, :line 5728, :record false, :end-line 5728, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta}}, min-key {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8711, :column 7, :end-line 8711, :end-column 14, :arglists (quote ([k x] [k x y] [k x y & more])), :doc "Returns the x for which (k x), a number, is least.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/min-key, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([k x] [k x y]), :arglists ([k x] [k x y] [k x y & more]), :arglists-meta (nil nil nil)}, :method-params ([k x] [k x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 8711, :end-line 8711, :max-fixed-arity 3, :fn-var true, :arglists ([k x] [k x y] [k x y & more]), :doc "Returns the x for which (k x), a number, is least."}, hash-iset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2856, :column 8, :end-line 2856, :end-column 17, :private true, :arglists (quote ([s]))}, :private true, :name cljs.core/hash-iset, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2856, :end-line 2856, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1323, :column 7, :end-line 1323, :end-column 14, :arglists (quote ([x])), :doc "Wraps x in a way such that a reduce will terminate with the value x"}, :name cljs.core/reduced, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1323, :end-line 1323, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Wraps x in a way such that a reduce will terminate with the value x"}, re-matches {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9094, :column 7, :end-line 9094, :end-column 17, :arglists (quote ([re s])), :doc "Returns the result of (re-find re s) if re fully matches s."}, :name cljs.core/re-matches, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([re s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9094, :end-line 9094, :max-fixed-arity 2, :fn-var true, :arglists (quote ([re s])), :doc "Returns the result of (re-find re s) if re fully matches s."}, pr-writer-impl {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9198, :column 8, :end-line 9198, :end-column 22, :private true, :arglists (quote ([obj writer opts]))}, :private true, :name cljs.core/pr-writer-impl, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9198, :end-line 9198, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts]))}, array-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8117, :column 7, :end-line 8117, :end-column 16, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new array map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/array-map, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8117, :end-line 8117, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new array map with supplied mappings."}, ITransientSet {:meta {:file "cljs/core.cljs", :line 713, :column 14, :end-line 713, :end-column 27, :doc "Protocol for adding set functionality to a transient collection.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-disjoin! [[tcoll v]]}}}, :protocol-symbol true, :name cljs.core/ITransientSet, :file "cljs/core.cljs", :end-column 27, :column 1, :line 713, :protocol-info {:methods {-disjoin! [[tcoll v]]}}, :info nil, :end-line 713, :impls #{cljs.core/TransientHashSet}, :doc "Protocol for adding set functionality to a transient collection.", :jsdoc ("@interface")}, ITER_SYMBOL {:name cljs.core/ITER_SYMBOL, :file "cljs/core.cljs", :line 289, :column 3, :end-line 289, :end-column 19, :meta {:file "cljs/core.cljs", :line 289, :column 8, :end-line 289, :end-column 19}}, unchecked-byte {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2552, :column 15, :end-line 2552, :end-column 29, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-byte, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2552, :ret-tag number, :end-line 2552, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, ArrayNode {:meta {:file "cljs/core.cljs", :line 6497, :column 10, :end-line 6497, :end-column 19, :declared true}, :num-fields 3, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/ArrayNode, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 6772, :record false, :declared true, :end-line 6772, :skip-protocol-flag nil}, ->ChunkedSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5249, :column 10, :end-line 5249, :end-column 20, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([vec node i off meta __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->ChunkedSeq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([vec node i off meta __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5249, :end-line 5249, :max-fixed-arity 6, :fn-var true, :arglists (quote ([vec node i off meta __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IChunkedNext cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/IChunkedSeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, every-pred {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4395, :column 7, :end-line 4395, :end-column 17, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/every-pred, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}, :method-params ([p] [p1 p2] [p1 p2 p3]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 4395, :end-line 4395, :max-fixed-arity 3, :fn-var true, :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates."}, keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8223, :column 7, :end-line 8223, :end-column 11, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's keys."}, :name cljs.core/keys, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([hash-map]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8223, :end-line 8223, :max-fixed-arity 1, :fn-var true, :arglists (quote ([hash-map])), :doc "Returns a sequence of the map's keys."}, missing-protocol {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 267, :column 7, :end-line 267, :end-column 23, :arglists (quote ([proto obj]))}, :name cljs.core/missing-protocol, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([proto obj]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 267, :end-line 267, :max-fixed-arity 2, :fn-var true, :arglists (quote ([proto obj]))}, load-file {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 282, :column 7, :end-line 282, :end-column 16, :arglists (quote ([file]))}, :name cljs.core/load-file, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([file]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 282, :end-line 282, :max-fixed-arity 1, :fn-var true, :arglists (quote ([file]))}, PersistentArrayMap {:num-fields 4, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/PersistentArrayMap, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 6172, :record false, :end-line 6172, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup cljs.core/IReduce}}, distinct? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2229, :column 16, :end-line 2229, :end-column 25, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns true if no two of the arguments are =", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/distinct?, :variadic true, :file "cljs/core.cljs", :end-column 25, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2229, :ret-tag boolean, :end-line 2229, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns true if no two of the arguments are ="}, pos-int? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2149, :column 16, :end-line 2149, :end-column 24, :tag boolean, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is positive."}, :name cljs.core/pos-int?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2149, :ret-tag boolean, :end-line 2149, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x satisfies int? and is positive."}, never-equiv {:name cljs.core/never-equiv, :file "cljs/core.cljs", :line 5805, :column 1, :end-line 5805, :end-column 27, :private true, :meta {:file "cljs/core.cljs", :line 5805, :column 16, :end-line 5805, :end-column 27, :private true}}, Stepper {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/Stepper, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 3853, :record false, :end-line 3853, :skip-protocol-flag nil}, unchecked-short {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2554, :column 15, :end-line 2554, :end-column 30, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-short, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2554, :ret-tag number, :end-line 2554, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, ->Range {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8826, :column 10, :end-line 8826, :end-column 15, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta start end step __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Range, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([meta start end step __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 8826, :end-line 8826, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta start end step __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, methods {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10220, :column 7, :end-line 10220, :end-column 14, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns"}, :name cljs.core/methods, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([multifn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10220, :end-line 10220, :max-fixed-arity 1, :fn-var true, :arglists (quote ([multifn])), :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns"}, odd? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4064, :column 16, :end-line 4064, :end-column 20, :tag boolean, :arglists (quote ([n])), :doc "Returns true if n is odd, throws an exception if n is not an integer"}, :name cljs.core/odd?, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4064, :ret-tag boolean, :end-line 4064, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([n])), :doc "Returns true if n is odd, throws an exception if n is not an integer"}, ->ArrayChunk {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3343, :column 10, :end-line 3343, :end-column 20, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}, :factory :positional, :arglists (quote ([arr off end]))}, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/->ArrayChunk, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([arr off end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3343, :end-line 3343, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr off end])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}}, lazy-transformer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3850, :column 7, :end-line 3850, :end-column 23, :arglists (quote ([stepper]))}, :name cljs.core/lazy-transformer, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([stepper]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3850, :end-line 3850, :max-fixed-arity 1, :fn-var true, :arglists (quote ([stepper]))}, ci-reduce {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1353, :column 8, :end-line 1353, :end-column 17, :private true, :arglists (quote ([cicoll f] [cicoll f val] [cicoll f val idx])), :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization", :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists-meta (nil nil nil)}}, :private true, :name cljs.core/ci-reduce, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists ([cicoll f] [cicoll f val] [cicoll f val idx]), :arglists-meta (nil nil nil)}, :method-params ([cicoll f] [cicoll f val] [cicoll f val idx]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 1353, :end-line 1353, :max-fixed-arity 4, :fn-var true, :arglists ([cicoll f] [cicoll f val] [cicoll f val idx]), :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization"}, *3 {:name cljs.core/*3, :file "cljs/core.cljs", :line 168, :column 1, :end-line 170, :end-column 5, :doc "bound in a repl thread to the third most recent value printed", :meta {:file "cljs/core.cljs", :line 170, :column 3, :end-line 170, :end-column 5, :doc "bound in a repl thread to the third most recent value printed"}}, -get-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10008, :column 4, :end-line 10008, :end-column 15, :protocol cljs.core/IMultiFn, :doc nil, :arglists (quote ([mf dispatch-val]))}, :protocol cljs.core/IMultiFn, :name cljs.core/-get-method, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([mf dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10003, :end-line 10008, :max-fixed-arity 2, :fn-var true, :arglists (quote ([mf dispatch-val])), :doc nil}, ->Var {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1012, :column 10, :end-line 1012, :end-column 13, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/IMeta cljs.core/Fn cljs.core/IDeref cljs.core/IWithMeta}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/IMeta cljs.core/IDeref cljs.core/IWithMeta}, :factory :positional, :arglists (quote ([val sym _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/Object cljs.core/IMeta cljs.core/Fn cljs.core/IDeref cljs.core/IWithMeta}, :name cljs.core/->Var, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([val sym _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1012, :end-line 1012, :max-fixed-arity 3, :fn-var true, :arglists (quote ([val sym _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/IMeta cljs.core/IDeref cljs.core/IWithMeta}}, frequencies {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8999, :column 7, :end-line 8999, :end-column 18, :arglists (quote ([coll])), :doc "Returns a map from distinct items in coll to the number of times\n  they appear."}, :name cljs.core/frequencies, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8999, :end-line 8999, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a map from distinct items in coll to the number of times\n  they appear."}, reduceable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2024, :column 16, :end-line 2024, :end-column 27, :tag boolean, :arglists (quote ([x])), :doc "Returns true if coll satisfies IReduce"}, :name cljs.core/reduceable?, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2024, :ret-tag boolean, :end-line 2024, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if coll satisfies IReduce"}, string-hash-cache {:name cljs.core/string-hash-cache, :file "cljs/core.cljs", :line 857, :column 1, :end-line 857, :end-column 23, :meta {:file "cljs/core.cljs", :line 857, :column 6, :end-line 857, :end-column 23}}, rsubseq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8800, :column 7, :end-line 8800, :end-column 14, :arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}}, :name cljs.core/rsubseq, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :arglists ([sc test key] [sc start-test start-key end-test end-key]), :arglists-meta (nil nil)}, :method-params ([sc test key] [sc start-test start-key end-test end-key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8800, :end-line 8800, :max-fixed-arity 5, :fn-var true, :arglists ([sc test key] [sc start-test start-key end-test end-key]), :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true"}, inc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1313, :column 7, :end-line 1313, :end-column 10, :arglists (quote ([x])), :doc "Returns a number one greater than num."}, :name cljs.core/inc, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1313, :end-line 1313, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a number one greater than num."}, type->str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 276, :column 7, :end-line 276, :end-column 16, :arglists (quote ([ty]))}, :name cljs.core/type->str, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([ty]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 276, :end-line 276, :max-fixed-arity 1, :fn-var true, :arglists (quote ([ty]))}, obj-clone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5856, :column 8, :end-line 5856, :end-column 17, :private true, :arglists (quote ([obj ks]))}, :private true, :name cljs.core/obj-clone, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([obj ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5856, :end-line 5856, :max-fixed-arity 2, :fn-var true, :arglists (quote ([obj ks]))}, get-method {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10224, :column 7, :end-line 10224, :end-column 17, :arglists (quote ([multifn dispatch-val])), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default"}, :name cljs.core/get-method, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([multifn dispatch-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10224, :end-line 10224, :max-fixed-arity 2, :fn-var true, :arglists (quote ([multifn dispatch-val])), :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default"}, uuid? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10286, :column 16, :end-line 10286, :end-column 21, :tag boolean, :arglists (quote ([x]))}, :name cljs.core/uuid?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10286, :ret-tag boolean, :end-line 10286, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x]))}, vector-index-out-of-bounds {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4946, :column 8, :end-line 4946, :end-column 34, :private true, :arglists (quote ([i cnt]))}, :private true, :name cljs.core/vector-index-out-of-bounds, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([i cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4946, :end-line 4946, :max-fixed-arity 2, :fn-var true, :arglists (quote ([i cnt]))}, es6-entries-iterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5999, :column 7, :end-line 5999, :end-column 27, :arglists (quote ([coll]))}, :name cljs.core/es6-entries-iterator, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5999, :end-line 5999, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, bit-clear {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2714, :column 7, :end-line 2714, :end-column 16, :arglists (quote ([x n])), :doc "Clear bit at index n"}, :name cljs.core/bit-clear, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2714, :end-line 2714, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x n])), :doc "Clear bit at index n"}, Range {:num-fields 5, :protocols #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/Range, :file "cljs/core.cljs", :end-column 15, :type true, :column 10, :line 8826, :record false, :end-line 8826, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, filter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4704, :column 7, :end-line 4704, :end-column 13, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/filter, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4704, :end-line 4704, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided."}, ->PersistentTreeMapSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7419, :column 10, :end-line 7419, :end-column 30, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta stack ascending? cnt __hash]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentTreeMapSeq, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([meta stack ascending? cnt __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7419, :end-line 7419, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta stack ascending? cnt __hash])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, create-array-node-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7123, :column 8, :end-line 7123, :end-column 29, :private true, :arglists (quote ([nodes] [meta nodes i s])), :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([nodes] [meta nodes i s]), :arglists ([nodes] [meta nodes i s]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/create-array-node-seq, :variadic false, :file "cljs/core.cljs", :end-column 29, :top-fn {:variadic false, :max-fixed-arity 4, :method-params ([nodes] [meta nodes i s]), :arglists ([nodes] [meta nodes i s]), :arglists-meta (nil nil)}, :method-params ([nodes] [meta nodes i s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7123, :end-line 7123, :max-fixed-arity 4, :fn-var true, :arglists ([nodes] [meta nodes i s])}, -assoc-n! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 708, :column 9, :end-line 708, :end-column 18, :tag clj, :protocol cljs.core/ITransientVector, :doc "Returns tcoll with value val added at position n.", :arglists (quote ([tcoll n val]))}, :protocol cljs.core/ITransientVector, :name cljs.core/-assoc-n!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll n val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 706, :ret-tag clj, :end-line 708, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll n val])), :doc "Returns tcoll with value val added at position n."}, IWithMeta {:meta {:file "cljs/core.cljs", :line 586, :column 14, :end-line 586, :end-column 23, :doc "Protocol for adding metadata to an object.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-with-meta [[o meta]]}}}, :protocol-symbol true, :name cljs.core/IWithMeta, :file "cljs/core.cljs", :end-column 23, :column 1, :line 586, :protocol-info {:methods {-with-meta [[o meta]]}}, :info nil, :end-line 586, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/t_cljs$core9610 cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/Var cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/Symbol cljs.core/MetaFn cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/t_cljs$core9607 cljs.core/RedNode}, :doc "Protocol for adding metadata to an object.", :jsdoc ("@interface")}, list {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3039, :column 7, :end-line 3039, :end-column 11, :arglists (quote ([& xs])), :doc "Creates a new list containing the items.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xs)], :arglists ([& xs]), :arglists-meta (nil)}}, :name cljs.core/list, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(xs)], :arglists ([& xs]), :arglists-meta (nil)}, :method-params [(xs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 3039, :end-line 3039, :max-fixed-arity 0, :fn-var true, :arglists ([& xs]), :doc "Creates a new list containing the items."}, + {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2441, :column 15, :end-line 2441, :end-column 16, :tag number, :arglists (quote ([] [x] [x y] [x y & more])), :doc "Returns the sum of nums. (+) returns 0.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/+, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([] [x] [x y]), :arglists ([] [x] [x y] [x y & more]), :arglists-meta (nil nil nil nil)}, :method-params ([] [x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 2441, :ret-tag number, :end-line 2441, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([] [x] [x y] [x y & more]), :doc "Returns the sum of nums. (+) returns 0."}, IndexedSeqIterator {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/IndexedSeqIterator, :file "cljs/core.cljs", :end-column 28, :type true, :column 10, :line 1461, :record false, :end-line 1461, :skip-protocol-flag nil}, split-with {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8953, :column 7, :end-line 8953, :end-column 17, :arglists (quote ([pred coll])), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"}, :name cljs.core/split-with, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8953, :end-line 8953, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"}, ->VectorNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4900, :column 10, :end-line 4900, :end-column 20, :protocols #{}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([edit arr]))}, :protocols #{}, :name cljs.core/->VectorNode, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([edit arr]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4900, :end-line 4900, :max-fixed-arity 2, :fn-var true, :arglists (quote ([edit arr])), :skip-protocol-flag nil}, aset {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 410, :column 7, :end-line 410, :end-column 11, :arglists (quote ([array i val] [array idx idx2 & idxv])), :doc "Sets the value at the index.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([array i val]), :arglists ([array i val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}}, :name cljs.core/aset, :variadic true, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([array i val]), :arglists ([array i val] [array idx idx2 & idxv]), :arglists-meta (nil nil)}, :method-params ([array i val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 410, :end-line 410, :max-fixed-arity 3, :fn-var true, :arglists ([array i val] [array idx idx2 & idxv]), :doc "Sets the value at the index."}, int-rotate-left {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 792, :column 15, :end-line 792, :end-column 30, :tag number, :arglists (quote ([x n]))}, :name cljs.core/int-rotate-left, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([x n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 792, :ret-tag number, :end-line 792, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x n]))}, keyword {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3222, :column 7, :end-line 3222, :end-column 14, :arglists (quote ([name] [ns name])), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}}, :name cljs.core/keyword, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([name] [ns name]), :arglists ([name] [ns name]), :arglists-meta (nil nil)}, :method-params ([name] [ns name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3222, :end-line 3222, :max-fixed-arity 2, :fn-var true, :arglists ([name] [ns name]), :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically."}, ->Cons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3056, :column 10, :end-line 3056, :end-column 14, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta first rest __hash]))}, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->Cons, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([meta first rest __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 3056, :end-line 3056, :max-fixed-arity 4, :fn-var true, :arglists (quote ([meta first rest __hash])), :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, *ns* {:meta {:file "cljs/core.cljs", :line 36, :column 3, :end-line 36, :end-column 7, :dynamic true, :doc "Var bound to the current namespace. Only used for bootstrapping.", :jsdoc ["@type {*}"]}, :name cljs.core/*ns*, :file "cljs/core.cljs", :end-column 7, :column 1, :dynamic true, :line 32, :end-line 36, :doc "Var bound to the current namespace. Only used for bootstrapping.", :jsdoc ["@type {*}"]}, *assert* {:name cljs.core/*assert*, :file "cljs/core.cljs", :line 43, :column 1, :end-line 45, :end-column 11, :dynamic true, :meta {:file "cljs/core.cljs", :line 45, :column 3, :end-line 45, :end-column 11, :dynamic true}}, create-tree-map-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7480, :column 8, :end-line 7480, :end-column 27, :private true, :arglists (quote ([tree ascending? cnt]))}, :private true, :name cljs.core/create-tree-map-seq, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([tree ascending? cnt]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7480, :end-line 7480, :max-fixed-arity 3, :fn-var true, :arglists (quote ([tree ascending? cnt]))}, ICollection {:meta {:file "cljs/core.cljs", :line 487, :column 14, :end-line 487, :end-column 25, :doc "Protocol for adding to a collection.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-conj [[coll o]]}}}, :protocol-symbol true, :name cljs.core/ICollection, :file "cljs/core.cljs", :end-column 25, :column 1, :line 487, :protocol-info {:methods {-conj [[coll o]]}}, :info nil, :end-line 487, :impls #{cljs.core/PersistentHashMap cljs.core/ObjMap cljs.core/Cons cljs.core/PersistentArrayMap cljs.core/NodeSeq cljs.core/PersistentQueue cljs.core/IndexedSeq cljs.core/BlackNode cljs.core/EmptyList cljs.core/LazySeq cljs.core/Subvec cljs.core/PersistentQueueSeq cljs.core/ArrayNodeSeq cljs.core/ValSeq cljs.core/PersistentArrayMapSeq cljs.core/PersistentVector cljs.core/List cljs.core/RSeq cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core/PersistentTreeSet cljs.core/ChunkedCons cljs.core/LazyTransformer cljs.core/Range cljs.core/PersistentTreeMapSeq cljs.core/RedNode}, :doc "Protocol for adding to a collection.", :jsdoc ("@interface")}, multi-stepper {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3907, :column 7, :end-line 3907, :end-column 20, :arglists (quote ([xform iters] [xform iters nexts])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([xform iters] [xform iters nexts]), :arglists ([xform iters] [xform iters nexts]), :arglists-meta (nil nil)}}, :name cljs.core/multi-stepper, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([xform iters] [xform iters nexts]), :arglists ([xform iters] [xform iters nexts]), :arglists-meta (nil nil)}, :method-params ([xform iters] [xform iters nexts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3907, :end-line 3907, :max-fixed-arity 3, :fn-var true, :arglists ([xform iters] [xform iters nexts])}, chars {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2661, :column 7, :end-line 2661, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/chars, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2661, :end-line 2661, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2799, :column 7, :end-line 2799, :end-column 10, :arglists (quote ([] [x] [x & ys])), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([] [x]), :arglists ([] [x] [x & ys]), :arglists-meta (nil nil nil)}}, :name cljs.core/str, :variadic true, :file "cljs/core.cljs", :end-column 10, :top-fn {:variadic true, :max-fixed-arity 1, :method-params ([] [x]), :arglists ([] [x] [x & ys]), :arglists-meta (nil nil nil)}, :method-params ([] [x]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2799, :end-line 2799, :max-fixed-arity 1, :fn-var true, :arglists ([] [x] [x & ys]), :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args."}, next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1151, :column 12, :end-line 1151, :end-column 16, :tag seq, :arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil"}, :name cljs.core/next, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1151, :ret-tag seq, :end-line 1151, :max-fixed-arity 1, :tag seq, :fn-var true, :arglists (quote ([coll])), :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil"}, ASeq {:meta {:file "cljs/core.cljs", :line 504, :column 14, :end-line 504, :end-column 18, :doc "Marker protocol indicating an array sequence.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/ASeq, :file "cljs/core.cljs", :end-column 18, :column 1, :line 504, :protocol-info {:methods {}}, :info nil, :end-line 504, :impls #{cljs.core/Cons cljs.core/IndexedSeq cljs.core/List cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Marker protocol indicating an array sequence.", :jsdoc ("@interface")}, pr-seq-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9281, :column 7, :end-line 9281, :end-column 20, :arglists (quote ([objs writer opts]))}, :name cljs.core/pr-seq-writer, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([objs writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9281, :end-line 9281, :max-fixed-arity 3, :fn-var true, :arglists (quote ([objs writer opts]))}, SeqIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/SeqIter, :file "cljs/core.cljs", :end-column 17, :type true, :column 10, :line 3818, :record false, :end-line 3818, :skip-protocol-flag nil}, IFn {:meta {:file "cljs/core.cljs", :line 443, :column 14, :end-line 443, :end-column 17, :doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-invoke [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]]}}}, :protocol-symbol true, :name cljs.core/IFn, :file "cljs/core.cljs", :end-column 17, :column 1, :line 443, :protocol-info {:methods {-invoke [[this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]]}}, :info nil, :end-line 443, :impls #{cljs.core/PersistentHashMap cljs.core/MultiFn cljs.core/ObjMap cljs.core/TransientVector cljs.core/PersistentArrayMap cljs.core/Keyword cljs.core/BlackNode cljs.core/Subvec cljs.core/Var cljs.core/PersistentVector cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet cljs.core/Symbol cljs.core/MetaFn cljs.core/RedNode}, :doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2", :jsdoc ("@interface")}, regexp? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9089, :column 16, :end-line 9089, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript RegExp instance."}, :name cljs.core/regexp?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9089, :ret-tag boolean, :end-line 9089, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript RegExp instance."}, hash-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8108, :column 7, :end-line 8108, :end-column 15, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new hash map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/hash-map, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8108, :end-line 8108, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new hash map with supplied mappings."}, underive {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9930, :column 7, :end-line 9930, :end-column 15, :arglists (quote ([tag parent] [h tag parent])), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}}, :name cljs.core/underive, :variadic false, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([tag parent] [h tag parent]), :arglists ([tag parent] [h tag parent]), :arglists-meta (nil nil)}, :method-params ([tag parent] [h tag parent]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9930, :end-line 9930, :max-fixed-arity 3, :fn-var true, :arglists ([tag parent] [h tag parent]), :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy."}, array-copy {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2071, :column 8, :end-line 2071, :end-column 18, :private true, :arglists (quote ([from i to j len]))}, :private true, :name cljs.core/array-copy, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([from i to j len]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2071, :end-line 2071, :max-fixed-arity 5, :fn-var true, :arglists (quote ([from i to j len]))}, obj-map-compare-keys {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5834, :column 8, :end-line 5834, :end-column 28, :private true, :arglists (quote ([a b]))}, :private true, :name cljs.core/obj-map-compare-keys, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5834, :end-line 5834, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, -reset! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 753, :column 4, :end-line 753, :end-column 11, :protocol cljs.core/IReset, :doc "Sets the value of o to new-value.", :arglists (quote ([o new-value]))}, :protocol cljs.core/IReset, :name cljs.core/-reset!, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([o new-value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 751, :end-line 753, :max-fixed-arity 2, :fn-var true, :arglists (quote ([o new-value])), :doc "Sets the value of o to new-value."}, -rest {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 511, :column 9, :end-line 511, :end-column 14, :tag clj, :protocol cljs.core/ISeq, :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :arglists (quote ([coll]))}, :protocol cljs.core/ISeq, :name cljs.core/-rest, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 507, :ret-tag clj, :end-line 511, :max-fixed-arity 1, :tag clj, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()"}, nil-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3784, :column 7, :end-line 3784, :end-column 15, :arglists (quote ([]))}, :name cljs.core/nil-iter, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3784, :end-line 3784, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, pr-writer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9272, :column 8, :end-line 9272, :end-column 17, :private true, :arglists (quote ([obj writer opts])), :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer."}, :private true, :name cljs.core/pr-writer, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([obj writer opts]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9272, :end-line 9272, :max-fixed-arity 3, :fn-var true, :arglists (quote ([obj writer opts])), :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer."}, false? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2091, :column 16, :end-line 2091, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is the value false, false otherwise."}, :name cljs.core/false?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2091, :ret-tag boolean, :end-line 2091, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is the value false, false otherwise."}, RangedIterator {:num-fields 6, :protocols #{cljs.core/Object}, :name cljs.core/RangedIterator, :file "cljs/core.cljs", :end-column 24, :type true, :column 10, :line 4997, :record false, :end-line 4997, :skip-protocol-flag nil}, *print-readably* {:name cljs.core/*print-readably*, :file "cljs/core.cljs", :line 85, :column 1, :end-line 91, :end-column 19, :dynamic true, :doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true", :meta {:file "cljs/core.cljs", :line 91, :column 3, :end-line 91, :end-column 19, :dynamic true, :doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true"}}, ints {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2663, :column 7, :end-line 2663, :end-column 11, :arglists (quote ([x]))}, :name cljs.core/ints, :variadic false, :file "cljs/core.cljs", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2663, :end-line 2663, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, some-fn {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4434, :column 7, :end-line 4434, :end-column 14, :arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}}, :name cljs.core/some-fn, :variadic true, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([p] [p1 p2] [p1 p2 p3]), :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :arglists-meta (nil nil nil nil)}, :method-params ([p] [p1 p2] [p1 p2 p3]), :protocol-impl nil, :arglists-meta (nil nil nil nil), :column 1, :line 4434, :end-line 4434, :max-fixed-arity 3, :fn-var true, :arglists ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps]), :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates."}, demunge-pattern {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10455, :column 8, :end-line 10455, :end-column 23, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/demunge-pattern, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10455, :end-line 10455, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, *flush-on-newline* {:name cljs.core/*flush-on-newline*, :file "cljs/core.cljs", :line 71, :column 1, :end-line 76, :end-column 21, :dynamic true, :doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.", :meta {:file "cljs/core.cljs", :line 76, :column 3, :end-line 76, :end-column 21, :dynamic true, :doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true."}}, to-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3471, :column 7, :end-line 3471, :end-column 15, :arglists (quote ([s])), :doc "Naive impl of to-array as a start."}, :name cljs.core/to-array, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3471, :end-line 3471, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Naive impl of to-array as a start."}, build-subvec {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5455, :column 8, :end-line 5455, :end-column 20, :private true, :arglists (quote ([meta v start end __hash]))}, :private true, :name cljs.core/build-subvec, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([meta v start end __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5455, :end-line 5455, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta v start end __hash]))}, Namespace {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object}, :name cljs.core/Namespace, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 10526, :record false, :end-line 10526, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash}}, list? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2946, :column 16, :end-line 2946, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x implements IList"}, :name cljs.core/list?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2946, :ret-tag boolean, :end-line 2946, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x implements IList"}, tree-map-remove {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7927, :column 8, :end-line 7927, :end-column 23, :private true, :arglists (quote ([comp tree k found]))}, :private true, :name cljs.core/tree-map-remove, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([comp tree k found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 7927, :end-line 7927, :max-fixed-arity 4, :fn-var true, :arglists (quote ([comp tree k found]))}, PersistentQueueIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/PersistentQueueIter, :file "cljs/core.cljs", :end-column 29, :type true, :column 10, :line 5665, :record false, :end-line 5665, :skip-protocol-flag nil}, HashCollisionNode {:num-fields 4, :protocols #{cljs.core/Object cljs.core/IIterable}, :name cljs.core/HashCollisionNode, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6882, :record false, :end-line 6882, :skip-protocol-flag nil}, array? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 195, :column 16, :end-line 195, :end-column 22, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript array."}, :name cljs.core/array?, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 195, :ret-tag boolean, :end-line 195, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript array."}, prefers* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9956, :column 8, :end-line 9956, :end-column 16, :private true, :arglists (quote ([x y prefer-table]))}, :private true, :name cljs.core/prefers*, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([x y prefer-table]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9956, :end-line 9956, :max-fixed-arity 3, :fn-var true, :arglists (quote ([x y prefer-table]))}, simple-ident? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3198, :column 16, :end-line 3198, :end-column 29, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword without a namespace"}, :name cljs.core/simple-ident?, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3198, :ret-tag boolean, :end-line 3198, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a symbol or keyword without a namespace"}, clone {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1094, :column 7, :end-line 1094, :end-column 12, :arglists (quote ([value])), :doc "Clone the supplied value which must implement ICloneable."}, :name cljs.core/clone, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([value]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1094, :end-line 1094, :max-fixed-arity 1, :fn-var true, :arglists (quote ([value])), :doc "Clone the supplied value which must implement ICloneable."}, scan-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5820, :column 8, :end-line 5820, :end-column 18, :private true, :arglists (quote ([incr k array]))}, :private true, :name cljs.core/scan-array, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([incr k array]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 5820, :end-line 5820, :max-fixed-arity 3, :fn-var true, :arglists (quote ([incr k array]))}, demunge {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10510, :column 7, :end-line 10510, :end-column 14, :arglists (quote ([name]))}, :name cljs.core/demunge, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([name]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10510, :end-line 10510, :max-fixed-arity 1, :fn-var true, :arglists (quote ([name]))}, bit-not {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2724, :column 7, :end-line 2724, :end-column 14, :arglists (quote ([x])), :doc "Bitwise complement"}, :name cljs.core/bit-not, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2724, :end-line 2724, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Bitwise complement"}, quote-string {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9184, :column 17, :end-line 9184, :end-column 29, :private true, :arglists (quote ([s]))}, :private true, :name cljs.core/quote-string, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9184, :end-line 9184, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, byte {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2538, :column 15, :end-line 2538, :end-column 19, :tag number, :arglists (quote ([x]))}, :name cljs.core/byte, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2538, :ret-tag number, :end-line 2538, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, max {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2524, :column 15, :end-line 2524, :end-column 18, :tag number, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns the greatest of the nums.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/max, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2524, :ret-tag number, :end-line 2524, :max-fixed-arity 2, :tag number, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns the greatest of the nums."}, IComparable {:meta {:file "cljs/core.cljs", :line 718, :column 14, :end-line 718, :end-column 25, :doc "Protocol for values that can be compared.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-compare [[x y]]}}}, :protocol-symbol true, :name cljs.core/IComparable, :file "cljs/core.cljs", :end-column 25, :column 1, :line 718, :protocol-info {:methods {-compare [[x y]]}}, :info nil, :end-line 718, :impls #{js/Date cljs.core/Keyword cljs.core/Subvec cljs.core/PersistentVector cljs.core/Symbol cljs.core/UUID}, :doc "Protocol for values that can be compared.", :jsdoc ("@interface")}, == {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2761, :column 16, :end-line 2761, :end-column 18, :tag boolean, :arglists (quote ([x] [x y] [x y & more])), :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}}, :name cljs.core/==, :variadic true, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([x] [x y]), :arglists ([x] [x y] [x y & more]), :arglists-meta (nil nil nil)}, :method-params ([x] [x y]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 2761, :ret-tag boolean, :end-line 2761, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists ([x] [x y] [x y & more]), :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined."}, parents {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9871, :column 7, :end-line 9871, :end-column 14, :arglists (quote ([tag] [h tag])), :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}}, :name cljs.core/parents, :variadic false, :file "cljs/core.cljs", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tag] [h tag]), :arglists ([tag] [h tag]), :arglists-meta (nil nil)}, :method-params ([tag] [h tag]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9871, :end-line 9871, :max-fixed-arity 2, :fn-var true, :arglists ([tag] [h tag]), :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy"}, count {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1701, :column 7, :end-line 1701, :end-column 12, :arglists (quote ([coll])), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps"}, :name cljs.core/count, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1701, :end-line 1701, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps"}, -disjoin! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 715, :column 9, :end-line 715, :end-column 18, :tag clj, :protocol cljs.core/ITransientSet, :doc "Returns tcoll without v.", :arglists (quote ([tcoll v]))}, :protocol cljs.core/ITransientSet, :name cljs.core/-disjoin!, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([tcoll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 713, :ret-tag clj, :end-line 715, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll v])), :doc "Returns tcoll without v."}, *loaded-libs* {:name cljs.core/*loaded-libs*, :file "cljs/core.cljs", :line 134, :column 1, :end-line 137, :end-column 16, :dynamic true, :jsdoc ["@type {*}"], :meta {:file "cljs/core.cljs", :line 137, :column 3, :end-line 137, :end-column 16, :dynamic true, :jsdoc ["@type {*}"]}}, ->TransientHashMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7307, :column 10, :end-line 7307, :end-column 26, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :factory :positional, :arglists (quote ([edit root count has-nil? nil-val]))}, :protocols #{cljs.core/ITransientMap cljs.core/Object cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientHashMap, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([edit root count has-nil? nil-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7307, :end-line 7307, :max-fixed-arity 5, :fn-var true, :arglists (quote ([edit root count has-nil? nil-val])), :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, array-index-of-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6035, :column 8, :end-line 6035, :end-column 30, :private true, :arglists (quote ([arr k]))}, :private true, :name cljs.core/array-index-of-symbol?, :variadic false, :file "cljs/core.cljs", :end-column 30, :method-params ([arr k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 6035, :end-line 6035, :max-fixed-arity 2, :fn-var true, :arglists (quote ([arr k]))}, ArrayChunk {:meta {:file "cljs/core.cljs", :line 3324, :column 10, :end-line 3324, :end-column 20, :declared true}, :num-fields 3, :protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IChunk cljs.core/IReduce}, :name cljs.core/ArrayChunk, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 3343, :record false, :declared true, :end-line 3343, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce}}, sorted-map-by {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8148, :column 7, :end-line 8148, :end-column 20, :arglists (quote ([comparator & keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator.", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keyvals)], :arglists ([comparator & keyvals]), :arglists-meta (nil)}}, :name cljs.core/sorted-map-by, :variadic true, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(comparator keyvals)], :arglists ([comparator & keyvals]), :arglists-meta (nil)}, :method-params [(comparator keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8148, :end-line 8148, :max-fixed-arity 1, :fn-var true, :arglists ([comparator & keyvals]), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator."}, apply {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3709, :column 7, :end-line 3709, :end-column 12, :arglists (quote ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args])), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([f args] [f x args] [f x y args] [f x y z args]), :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :arglists-meta (nil nil nil nil nil)}}, :name cljs.core/apply, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 5, :method-params ([f args] [f x args] [f x y args] [f x y z args]), :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :arglists-meta (nil nil nil nil nil)}, :method-params ([f args] [f x args] [f x y args] [f x y z args]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil), :column 1, :line 3709, :end-line 3709, :max-fixed-arity 5, :fn-var true, :arglists ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args]), :doc "Applies fn f to the argument list formed by prepending intervening arguments to args."}, get-global-hierarchy {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9843, :column 8, :end-line 9843, :end-column 28, :private true, :arglists (quote ([]))}, :private true, :name cljs.core/get-global-hierarchy, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9843, :end-line 9843, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, add-to-string-hash-cache {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 872, :column 7, :end-line 872, :end-column 31, :arglists (quote ([k]))}, :name cljs.core/add-to-string-hash-cache, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 872, :end-line 872, :max-fixed-arity 1, :fn-var true, :arglists (quote ([k]))}, clj->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9720, :column 7, :end-line 9720, :end-column 14, :arglists (quote ([x])), :doc "Recursively transforms ClojureScript values to JavaScript.\n  sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\n  Maps become Objects. Arbitrary keys are encoded to by key->js."}, :name cljs.core/clj->js, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9720, :end-line 9720, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively transforms ClojureScript values to JavaScript.\n  sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\n  Maps become Objects. Arbitrary keys are encoded to by key->js."}, TransientArrayMap {:meta {:file "cljs/core.cljs", :line 6092, :column 10, :end-line 6092, :end-column 27, :declared true}, :num-fields 3, :protocols #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/TransientArrayMap, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6357, :record false, :declared true, :end-line 6357, :skip-protocol-flag #{cljs.core/ITransientMap cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientAssociative cljs.core/ILookup}}, ->TransientVector {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5532, :column 10, :end-line 5532, :end-column 25, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :factory :positional, :arglists (quote ([cnt shift root tail]))}, :protocols #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}, :name cljs.core/->TransientVector, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([cnt shift root tail]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5532, :end-line 5532, :max-fixed-arity 4, :fn-var true, :arglists (quote ([cnt shift root tail])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IFn cljs.core/ICounted cljs.core/ITransientCollection cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ILookup}}, IChunkedNext {:meta {:file "cljs/core.cljs", :line 736, :column 14, :end-line 736, :end-column 26, :doc "Protocol for accessing the chunks of a collection.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-chunked-next [[coll]]}}}, :protocol-symbol true, :name cljs.core/IChunkedNext, :file "cljs/core.cljs", :end-column 26, :column 1, :line 736, :protocol-info {:methods {-chunked-next [[coll]]}}, :info nil, :end-line 736, :impls #{cljs.core/ChunkedSeq cljs.core/ChunkedCons}, :doc "Protocol for accessing the chunks of a collection.", :jsdoc ("@interface")}, interpose {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4658, :column 7, :end-line 4658, :end-column 16, :arglists (quote ([sep] [sep coll])), :doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sep] [sep coll]), :arglists ([sep] [sep coll]), :arglists-meta (nil nil)}}, :name cljs.core/interpose, :variadic false, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([sep] [sep coll]), :arglists ([sep] [sep coll]), :arglists-meta (nil nil)}, :method-params ([sep] [sep coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4658, :end-line 4658, :max-fixed-arity 2, :fn-var true, :arglists ([sep] [sep coll]), :doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided."}, ->BlackNode {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 7586, :column 10, :end-line 7586, :end-column 19, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([key val left right __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->BlackNode, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([key val left right __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 7586, :end-line 7586, :max-fixed-arity 5, :fn-var true, :arglists (quote ([key val left right __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, deref {:name cljs.core/deref, :file "cljs/core.cljs", :line 6438, :column 1, :end-line 6438, :end-column 78, :declared true, :meta {:file "cljs/core.cljs", :line 6438, :column 73, :end-line 6438, :end-column 78, :declared true}}, pv-aget {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4905, :column 8, :end-line 4905, :end-column 15, :private true, :arglists (quote ([node idx]))}, :private true, :name cljs.core/pv-aget, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([node idx]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4905, :end-line 4905, :max-fixed-arity 2, :fn-var true, :arglists (quote ([node idx]))}, assoc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1860, :column 7, :end-line 1860, :end-column 12, :arglists (quote ([coll k v] [coll k v & kvs])), :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([coll k v]), :arglists ([coll k v] [coll k v & kvs]), :arglists-meta (nil nil)}}, :name cljs.core/assoc, :variadic true, :file "cljs/core.cljs", :end-column 12, :top-fn {:variadic true, :max-fixed-arity 3, :method-params ([coll k v]), :arglists ([coll k v] [coll k v & kvs]), :arglists-meta (nil nil)}, :method-params ([coll k v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1860, :end-line 1860, :max-fixed-arity 3, :fn-var true, :arglists ([coll k v] [coll k v & kvs]), :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index."}, transient {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3638, :column 7, :end-line 3638, :end-column 16, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, :name cljs.core/transient, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3638, :end-line 3638, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns a new, transient version of the collection, in constant time."}, -disjoin {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 555, :column 9, :end-line 555, :end-column 17, :tag clj, :protocol cljs.core/ISet, :doc "Returns a new collection of coll that does not contain v.", :arglists (quote ([coll v]))}, :protocol cljs.core/ISet, :name cljs.core/-disjoin, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([coll v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 553, :ret-tag clj, :end-line 555, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([coll v])), :doc "Returns a new collection of coll that does not contain v."}, chunk-cons {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3447, :column 7, :end-line 3447, :end-column 17, :arglists (quote ([chunk rest]))}, :name cljs.core/chunk-cons, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([chunk rest]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3447, :end-line 3447, :max-fixed-arity 2, :fn-var true, :arglists (quote ([chunk rest]))}, ArrayIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/ArrayIter, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 3803, :record false, :end-line 3803, :skip-protocol-flag nil}, comparator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 10360, :column 7, :end-line 10360, :end-column 17, :arglists (quote ([pred])), :doc "Returns an JavaScript compatible comparator based upon pred."}, :name cljs.core/comparator, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([pred]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 10360, :end-line 10360, :max-fixed-arity 1, :fn-var true, :arglists (quote ([pred])), :doc "Returns an JavaScript compatible comparator based upon pred."}, sorted-map {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 8139, :column 7, :end-line 8139, :end-column 17, :arglists (quote ([& keyvals])), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}}, :name cljs.core/sorted-map, :variadic true, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(keyvals)], :arglists ([& keyvals]), :arglists-meta (nil)}, :method-params [(keyvals)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 8139, :end-line 8139, :max-fixed-arity 0, :fn-var true, :arglists ([& keyvals]), :doc "keyval => key val\n  Returns a new sorted map with supplied mappings."}, drop-while {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4586, :column 7, :end-line 4586, :end-column 17, :arglists (quote ([pred] [pred coll])), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}}, :name cljs.core/drop-while, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([pred] [pred coll]), :arglists ([pred] [pred coll]), :arglists-meta (nil nil)}, :method-params ([pred] [pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4586, :end-line 4586, :max-fixed-arity 2, :fn-var true, :arglists ([pred] [pred coll]), :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided."}, IWriter {:meta {:file "cljs/core.cljs", :line 652, :column 14, :end-line 652, :end-column 21, :doc "Protocol for writing. Currently only implemented by StringBufferWriter.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-write [[writer s]], -flush [[writer]]}}}, :protocol-symbol true, :name cljs.core/IWriter, :file "cljs/core.cljs", :end-column 21, :column 1, :line 652, :protocol-info {:methods {-write [[writer s]], -flush [[writer]]}}, :info nil, :end-line 652, :impls #{cljs.core/StringBufferWriter}, :doc "Protocol for writing. Currently only implemented by StringBufferWriter.", :jsdoc ("@interface")}, KeySeq {:num-fields 2, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/KeySeq, :file "cljs/core.cljs", :end-column 16, :type true, :column 10, :line 8158, :record false, :end-line 8158, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, realized? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9610, :column 16, :end-line 9610, :end-column 25, :tag boolean, :arglists (quote ([x])), :doc "Returns true if a value has been produced for a delay or lazy sequence."}, :name cljs.core/realized?, :variadic false, :file "cljs/core.cljs", :end-column 25, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9610, :ret-tag boolean, :end-line 9610, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if a value has been produced for a delay or lazy sequence."}, *print-fn* {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 51, :column 3, :end-line 51, :end-column 13, :doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.", :dynamic true}, :name cljs.core/*print-fn*, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([_]), :protocol-impl nil, :arglists-meta (), :column 1, :dynamic true, :line 47, :end-line 51, :max-fixed-arity 1, :fn-var true, :arglists nil, :doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed."}, compare {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2247, :column 15, :end-line 2247, :end-column 22, :tag number, :arglists (quote ([x y])), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object."}, :name cljs.core/compare, :variadic false, :file "cljs/core.cljs", :end-column 22, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2247, :ret-tag number, :end-line 2247, :max-fixed-arity 2, :tag number, :fn-var true, :arglists (quote ([x y])), :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object."}, complement {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4068, :column 16, :end-line 4068, :end-column 26, :tag boolean, :arglists (quote ([f])), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value."}, :name cljs.core/complement, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4068, :ret-tag boolean, :end-line 4068, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([f])), :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value."}, lookup-sentinel {:name cljs.core/lookup-sentinel, :file "cljs/core.cljs", :line 2089, :column 1, :end-line 2089, :end-column 31, :private true, :meta {:file "cljs/core.cljs", :line 2089, :column 16, :end-line 2089, :end-column 31, :private true}}, -assoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 697, :column 9, :end-line 697, :end-column 16, :tag clj, :protocol cljs.core/ITransientAssociative, :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :arglists (quote ([tcoll key val]))}, :protocol cljs.core/ITransientAssociative, :name cljs.core/-assoc!, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([tcoll key val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 695, :ret-tag clj, :end-line 697, :max-fixed-arity 3, :tag clj, :fn-var true, :arglists (quote ([tcoll key val])), :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it."}, *print-dup* {:name cljs.core/*print-dup*, :file "cljs/core.cljs", :line 101, :column 1, :end-line 107, :end-column 14, :dynamic true, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", :meta {:file "cljs/core.cljs", :line 107, :column 3, :end-line 107, :end-column 14, :dynamic true, :doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false."}}, string-iter {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3800, :column 7, :end-line 3800, :end-column 18, :arglists (quote ([x]))}, :name cljs.core/string-iter, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3800, :end-line 3800, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, -key->js {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9705, :column 4, :end-line 9705, :end-column 12, :protocol cljs.core/IEncodeJS, :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)", :arglists (quote ([x]))}, :protocol cljs.core/IEncodeJS, :name cljs.core/-key->js, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9703, :end-line 9705, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)"}, IDeref {:meta {:file "cljs/core.cljs", :line 573, :column 14, :end-line 573, :end-column 20, :doc "Protocol for adding dereference functionality to a reference.", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-deref [[o]]}}}, :protocol-symbol true, :name cljs.core/IDeref, :file "cljs/core.cljs", :end-column 20, :column 1, :line 573, :protocol-info {:methods {-deref [[o]]}}, :info nil, :end-line 573, :impls #{cljs.core/Reduced cljs.core/Volatile cljs.core/Delay cljs.core/Var cljs.core/Atom}, :doc "Protocol for adding dereference functionality to a reference.", :jsdoc ("@interface")}, sequence {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4012, :column 7, :end-line 4012, :end-column 15, :arglists (quote ([coll] [xform coll] [xform coll & colls])), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [xform coll]), :arglists ([coll] [xform coll] [xform coll & colls]), :arglists-meta (nil nil nil)}}, :name cljs.core/sequence, :variadic true, :file "cljs/core.cljs", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([coll] [xform coll]), :arglists ([coll] [xform coll] [xform coll & colls]), :arglists-meta (nil nil nil)}, :method-params ([coll] [xform coll]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 4012, :end-line 4012, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [xform coll] [xform coll & colls]), :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments"}, constantly {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4078, :column 7, :end-line 4078, :end-column 17, :arglists (quote ([x])), :doc "Returns a function that takes any number of arguments and returns x."}, :name cljs.core/constantly, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4078, :end-line 4078, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a function that takes any number of arguments and returns x."}, ->RangedIterator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4997, :column 10, :end-line 4997, :end-column 24, :protocols #{cljs.core/Object}, :skip-protocol-flag nil, :factory :positional, :arglists (quote ([i base arr v start end]))}, :protocols #{cljs.core/Object}, :name cljs.core/->RangedIterator, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([i base arr v start end]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 4997, :end-line 4997, :max-fixed-arity 6, :fn-var true, :arglists (quote ([i base arr v start end])), :skip-protocol-flag nil}, chunked-seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5333, :column 7, :end-line 5333, :end-column 18, :arglists (quote ([vec i off] [vec node i off] [vec node i off meta])), :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :arglists ([vec i off] [vec node i off] [vec node i off meta]), :arglists-meta (nil nil nil)}}, :name cljs.core/chunked-seq, :variadic false, :file "cljs/core.cljs", :end-column 18, :top-fn {:variadic false, :max-fixed-arity 5, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :arglists ([vec i off] [vec node i off] [vec node i off meta]), :arglists-meta (nil nil nil)}, :method-params ([vec i off] [vec node i off] [vec node i off meta]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 5333, :end-line 5333, :max-fixed-arity 5, :fn-var true, :arglists ([vec i off] [vec node i off] [vec node i off meta])}, ISorted {:meta {:file "cljs/core.cljs", :line 635, :column 14, :end-line 635, :end-column 21, :doc "Protocol for a collection which can represent their items\n  in a sorted manner. ", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {-sorted-seq [[coll ascending?]], -sorted-seq-from [[coll k ascending?]], -entry-key [[coll entry]], -comparator [[coll]]}}}, :protocol-symbol true, :name cljs.core/ISorted, :file "cljs/core.cljs", :end-column 21, :column 1, :line 635, :protocol-info {:methods {-sorted-seq [[coll ascending?]], -sorted-seq-from [[coll k ascending?]], -entry-key [[coll entry]], -comparator [[coll]]}}, :info nil, :end-line 635, :impls #{cljs.core/PersistentTreeMap cljs.core/PersistentTreeSet}, :doc "Protocol for a collection which can represent their items\n  in a sorted manner. ", :jsdoc ("@interface")}, make-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 366, :column 14, :end-line 366, :end-column 24, :tag array, :arglists (quote ([size] [type size] [type size & more-sizes])), :doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([size] [type size]), :arglists ([size] [type size] [type size & more-sizes]), :arglists-meta (nil nil nil)}}, :name cljs.core/make-array, :variadic true, :file "cljs/core.cljs", :end-column 24, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([size] [type size]), :arglists ([size] [type size] [type size & more-sizes]), :arglists-meta (nil nil nil)}, :method-params ([size] [type size]), :protocol-impl nil, :arglists-meta (nil nil nil), :column 1, :line 366, :ret-tag array, :end-line 366, :max-fixed-arity 2, :tag array, :fn-var true, :arglists ([size] [type size] [type size & more-sizes]), :doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments."}, shorts {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2662, :column 7, :end-line 2662, :end-column 13, :arglists (quote ([x]))}, :name cljs.core/shorts, :variadic false, :file "cljs/core.cljs", :end-column 13, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2662, :end-line 2662, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, *unchecked-if* {:name cljs.core/*unchecked-if*, :file "cljs/core.cljs", :line 20, :column 1, :end-line 20, :end-column 20, :meta {:file "cljs/core.cljs", :line 20, :column 6, :end-line 20, :end-column 20}}, ->RSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1574, :column 10, :end-line 1574, :end-column 14, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([ci i meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->RSeq, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([ci i meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1574, :end-line 1574, :max-fixed-arity 3, :fn-var true, :arglists (quote ([ci i meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, enable-console-print! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 148, :column 7, :end-line 148, :end-column 28, :arglists (quote ([])), :doc "Set *print-fn* to console.log"}, :name cljs.core/enable-console-print!, :variadic false, :file "cljs/core.cljs", :end-column 28, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 148, :end-line 148, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Set *print-fn* to console.log"}, -flush {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 656, :column 4, :end-line 656, :end-column 10, :protocol cljs.core/IWriter, :doc "Flush writer.", :arglists (quote ([writer]))}, :protocol cljs.core/IWriter, :name cljs.core/-flush, :variadic false, :file "cljs/core.cljs", :end-column 10, :method-params ([writer]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 652, :end-line 656, :max-fixed-arity 1, :fn-var true, :arglists (quote ([writer])), :doc "Flush writer."}, -lastIndexOf {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1444, :column 8, :end-line 1444, :end-column 20, :private true, :arglists (quote ([coll x] [coll x start])), :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll x] [coll x start]), :arglists ([coll x] [coll x start]), :arglists-meta (nil nil)}}, :private true, :name cljs.core/-lastIndexOf, :variadic false, :file "cljs/core.cljs", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([coll x] [coll x start]), :arglists ([coll x] [coll x start]), :arglists-meta (nil nil)}, :method-params ([coll x] [coll x start]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1444, :end-line 1444, :max-fixed-arity 3, :fn-var true, :arglists ([coll x] [coll x start])}, completing {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2412, :column 7, :end-line 2412, :end-column 17, :arglists (quote ([f] [f cf])), :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f cf]), :arglists ([f] [f cf]), :arglists-meta (nil nil)}}, :name cljs.core/completing, :variadic false, :file "cljs/core.cljs", :end-column 17, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([f] [f cf]), :arglists ([f] [f cf]), :arglists-meta (nil nil)}, :method-params ([f] [f cf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2412, :end-line 2412, :max-fixed-arity 2, :fn-var true, :arglists ([f] [f cf]), :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument."}, unchecked-negate-int {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2612, :column 7, :end-line 2612, :end-column 27, :arglists (quote ([x]))}, :name cljs.core/unchecked-negate-int, :variadic false, :file "cljs/core.cljs", :end-column 27, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2612, :end-line 2612, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->PersistentVector {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5019, :column 10, :end-line 5019, :end-column 26, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :factory :positional, :arglists (quote ([meta cnt shift root tail __hash]))}, :protocols #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/IIterable cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}, :name cljs.core/->PersistentVector, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([meta cnt shift root tail __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5019, :end-line 5019, :max-fixed-arity 6, :fn-var true, :arglists (quote ([meta cnt shift root tail __hash])), :skip-protocol-flag #{cljs.core/IIndexed cljs.core/IVector cljs.core/IReversible cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/IMapEntry cljs.core/ISequential cljs.core/IWithMeta cljs.core/IAssociative cljs.core/ILookup cljs.core/IReduce}}, equiv-sequential {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2821, :column 8, :end-line 2821, :end-column 24, :private true, :arglists (quote ([x y])), :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false."}, :private true, :name cljs.core/equiv-sequential, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([x y]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2821, :end-line 2821, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x y])), :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false."}, hash-unordered-coll {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1241, :column 15, :end-line 1241, :end-column 34, :tag number, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms."}, :name cljs.core/hash-unordered-coll, :variadic false, :file "cljs/core.cljs", :end-column 34, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1241, :ret-tag number, :end-line 1241, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([coll])), :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms."}, repeat {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4622, :column 7, :end-line 4622, :end-column 13, :arglists (quote ([x] [n x])), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([x] [n x]), :arglists ([x] [n x]), :arglists-meta (nil nil)}}, :name cljs.core/repeat, :variadic false, :file "cljs/core.cljs", :end-column 13, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([x] [n x]), :arglists ([x] [n x]), :arglists-meta (nil nil)}, :method-params ([x] [n x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4622, :end-line 4622, :max-fixed-arity 2, :fn-var true, :arglists ([x] [n x]), :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs."}, unchecked-inc {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2589, :column 7, :end-line 2589, :end-column 20, :arglists (quote ([x]))}, :name cljs.core/unchecked-inc, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2589, :end-line 2589, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, nthnext {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2789, :column 7, :end-line 2789, :end-column 14, :arglists (quote ([coll n])), :doc "Returns the nth next of coll, (seq coll) when n is 0."}, :name cljs.core/nthnext, :variadic false, :file "cljs/core.cljs", :end-column 14, :method-params ([coll n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2789, :end-line 2789, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll n])), :doc "Returns the nth next of coll, (seq coll) when n is 0."}, preserving-reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9615, :column 8, :end-line 9615, :end-column 26, :private true, :arglists (quote ([rf]))}, :private true, :name cljs.core/preserving-reduced, :variadic false, :file "cljs/core.cljs", :end-column 26, :method-params ([rf]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 9615, :end-line 9615, :max-fixed-arity 1, :fn-var true, :arglists (quote ([rf]))}, get-validator {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4332, :column 7, :end-line 4332, :end-column 20, :arglists (quote ([iref])), :doc "Gets the validator-fn for a var/ref/agent/atom."}, :name cljs.core/get-validator, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([iref]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4332, :end-line 4332, :max-fixed-arity 1, :fn-var true, :arglists (quote ([iref])), :doc "Gets the validator-fn for a var/ref/agent/atom."}, StringIter {:num-fields 2, :protocols #{cljs.core/Object}, :name cljs.core/StringIter, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 3791, :record false, :end-line 3791, :skip-protocol-flag nil}, number? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 202, :column 16, :end-line 202, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript number."}, :name cljs.core/number?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 202, :ret-tag boolean, :end-line 202, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x is a JavaScript number."}, -conj! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 690, :column 9, :end-line 690, :end-column 15, :tag clj, :protocol cljs.core/ITransientCollection, :doc "Adds value val to tcoll and returns tcoll.", :arglists (quote ([tcoll val]))}, :protocol cljs.core/ITransientCollection, :name cljs.core/-conj!, :variadic false, :file "cljs/core.cljs", :end-column 15, :method-params ([tcoll val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 688, :ret-tag clj, :end-line 690, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll val])), :doc "Adds value val to tcoll and returns tcoll."}, ->PersistentArrayMapSeq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 6094, :column 10, :end-line 6094, :end-column 31, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :factory :positional, :arglists (quote ([arr i _meta]))}, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/->PersistentArrayMapSeq, :variadic false, :file "cljs/core.cljs", :end-column 31, :method-params ([arr i _meta]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 6094, :end-line 6094, :max-fixed-arity 3, :fn-var true, :arglists (quote ([arr i _meta])), :skip-protocol-flag #{cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, chunk-next {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3464, :column 7, :end-line 3464, :end-column 17, :arglists (quote ([s]))}, :name cljs.core/chunk-next, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3464, :end-line 3464, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, ArrayList {:num-fields 1, :protocols #{cljs.core/Object}, :name cljs.core/ArrayList, :file "cljs/core.cljs", :end-column 19, :type true, :column 10, :line 8718, :record false, :end-line 8718, :skip-protocol-flag nil}, print-str {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 9350, :column 7, :end-line 9350, :end-column 16, :arglists (quote ([& objs])), :doc "print to a string, returning it", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}}, :name cljs.core/print-str, :variadic true, :file "cljs/core.cljs", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(objs)], :arglists ([& objs]), :arglists-meta (nil)}, :method-params [(objs)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 9350, :end-line 9350, :max-fixed-arity 0, :fn-var true, :arglists ([& objs]), :doc "print to a string, returning it"}, not-any? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 4053, :column 16, :end-line 4053, :end-column 24, :tag boolean, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true."}, :name cljs.core/not-any?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([pred coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4053, :ret-tag boolean, :end-line 4053, :max-fixed-arity 2, :tag boolean, :fn-var true, :arglists (quote ([pred coll])), :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true."}, into-array {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 424, :column 14, :end-line 424, :end-column 24, :tag array, :arglists (quote ([aseq] [type aseq])), :doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([aseq] [type aseq]), :arglists ([aseq] [type aseq]), :arglists-meta (nil nil)}}, :name cljs.core/into-array, :variadic false, :file "cljs/core.cljs", :end-column 24, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([aseq] [type aseq]), :arglists ([aseq] [type aseq]), :arglists-meta (nil nil)}, :method-params ([aseq] [type aseq]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 424, :ret-tag array, :end-line 424, :max-fixed-arity 2, :tag array, :fn-var true, :arglists ([aseq] [type aseq]), :doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure."}, -hash {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 613, :column 4, :end-line 613, :end-column 9, :protocol cljs.core/IHash, :doc "Returns the hash code of o.", :arglists (quote ([o]))}, :protocol cljs.core/IHash, :name cljs.core/-hash, :variadic false, :file "cljs/core.cljs", :end-column 9, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 611, :end-line 613, :max-fixed-arity 1, :fn-var true, :arglists (quote ([o])), :doc "Returns the hash code of o."}, qualified-symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3210, :column 16, :end-line 3210, :end-column 33, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a symbol with a namespace"}, :name cljs.core/qualified-symbol?, :variadic false, :file "cljs/core.cljs", :end-column 33, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3210, :ret-tag boolean, :end-line 3210, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a symbol with a namespace"}, -dissoc! {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 703, :column 9, :end-line 703, :end-column 17, :tag clj, :protocol cljs.core/ITransientMap, :doc "Returns a new transient collection of tcoll without the mapping for key.", :arglists (quote ([tcoll key]))}, :protocol cljs.core/ITransientMap, :name cljs.core/-dissoc!, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([tcoll key]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 701, :ret-tag clj, :end-line 703, :max-fixed-arity 2, :tag clj, :fn-var true, :arglists (quote ([tcoll key])), :doc "Returns a new transient collection of tcoll without the mapping for key."}, ->Reduced {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1319, :column 10, :end-line 1319, :end-column 17, :protocols #{cljs.core/IDeref}, :skip-protocol-flag #{cljs.core/IDeref}, :factory :positional, :arglists (quote ([val]))}, :protocols #{cljs.core/IDeref}, :name cljs.core/->Reduced, :variadic false, :file "cljs/core.cljs", :end-column 17, :method-params ([val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 1319, :end-line 1319, :max-fixed-arity 1, :fn-var true, :arglists (quote ([val])), :skip-protocol-flag #{cljs.core/IDeref}}, chunk-buffer {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 3340, :column 7, :end-line 3340, :end-column 19, :arglists (quote ([capacity]))}, :name cljs.core/chunk-buffer, :variadic false, :file "cljs/core.cljs", :end-column 19, :method-params ([capacity]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 3340, :end-line 3340, :max-fixed-arity 1, :fn-var true, :arglists (quote ([capacity]))}, seqable? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2115, :column 16, :end-line 2115, :end-column 24, :tag boolean, :arglists (quote ([s])), :doc "Return true if s satisfies ISeqable"}, :name cljs.core/seqable?, :variadic false, :file "cljs/core.cljs", :end-column 24, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2115, :ret-tag boolean, :end-line 2115, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([s])), :doc "Return true if s satisfies ISeqable"}, symbol? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 938, :column 16, :end-line 938, :end-column 23, :tag boolean, :arglists (quote ([x])), :doc "Return true if x is a Symbol"}, :name cljs.core/symbol?, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 938, :ret-tag boolean, :end-line 938, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Return true if x is a Symbol"}, m3-hash-unencoded-chars {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 838, :column 15, :end-line 838, :end-column 38, :tag number, :arglists (quote ([in]))}, :name cljs.core/m3-hash-unencoded-chars, :variadic false, :file "cljs/core.cljs", :end-column 38, :method-params ([in]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 838, :ret-tag number, :end-line 838, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([in]))}, unchecked-char {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2553, :column 15, :end-line 2553, :end-column 29, :tag number, :arglists (quote ([x]))}, :name cljs.core/unchecked-char, :variadic false, :file "cljs/core.cljs", :end-column 29, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2553, :ret-tag number, :end-line 2553, :max-fixed-arity 1, :tag number, :fn-var true, :arglists (quote ([x]))}, system-time {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 347, :column 7, :end-line 347, :end-column 18, :arglists (quote ([])), :doc "Returns highest resolution time offered by host in milliseconds."}, :name cljs.core/system-time, :variadic false, :file "cljs/core.cljs", :end-column 18, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 347, :end-line 347, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Returns highest resolution time offered by host in milliseconds."}, NeverEquiv {:num-fields 0, :protocols #{cljs.core/IEquiv cljs.core/Object}, :name cljs.core/NeverEquiv, :file "cljs/core.cljs", :end-column 20, :type true, :column 10, :line 5798, :record false, :end-line 5798, :skip-protocol-flag #{cljs.core/IEquiv}}, -invoke {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 447, :column 4, :end-line 447, :end-column 11, :protocol cljs.core/IFn, :doc nil, :arglists (quote ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest])), :top-fn {:variadic false, :max-fixed-arity 22, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists-meta (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)}}, :protocol cljs.core/IFn, :name cljs.core/-invoke, :variadic false, :file "cljs/core.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 22, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :arglists-meta (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil)}, :method-params ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :protocol-impl nil, :arglists-meta (nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil), :column 1, :line 443, :end-line 447, :max-fixed-arity 22, :fn-var true, :arglists ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q r] [this a b c d e f g h i j k l m n o p q r s] [this a b c d e f g h i j k l m n o p q r s t] [this a b c d e f g h i j k l m n o p q r s t rest]), :doc nil}, coll? {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1998, :column 16, :end-line 1998, :end-column 21, :tag boolean, :arglists (quote ([x])), :doc "Returns true if x satisfies ICollection"}, :name cljs.core/coll?, :variadic false, :file "cljs/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1998, :ret-tag boolean, :end-line 1998, :max-fixed-arity 1, :tag boolean, :fn-var true, :arglists (quote ([x])), :doc "Returns true if x satisfies ICollection"}, get-in {:protocol-inline nil, :meta {:added "1.2", :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([m ks] [m ks not-found]), :arglists ([m ks] [m ks not-found]), :arglists-meta (nil nil)}, :column 7, :line 4827, :end-line 4827, :arglists (quote ([m ks] [m ks not-found])), :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied."}, :added "1.2", :name cljs.core/get-in, :variadic false, :file "cljs/core.cljs", :end-column 13, :static true, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([m ks] [m ks not-found]), :arglists ([m ks] [m ks not-found]), :arglists-meta (nil nil)}, :method-params ([m ks] [m ks not-found]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 4827, :end-line 4827, :max-fixed-arity 3, :fn-var true, :arglists ([m ks] [m ks not-found]), :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied."}, fnext {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 1652, :column 7, :end-line 1652, :end-column 12, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, :name cljs.core/fnext, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 1652, :end-line 1652, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Same as (first (next x))"}, IList {:meta {:file "cljs/core.cljs", :line 624, :column 14, :end-line 624, :end-column 19, :doc "Marker interface indicating a persistent list", :protocol-symbol true, :jsdoc ("@interface"), :protocol-info {:methods {}}}, :protocol-symbol true, :name cljs.core/IList, :file "cljs/core.cljs", :end-column 19, :column 1, :line 624, :protocol-info {:methods {}}, :info nil, :end-line 624, :impls #{cljs.core/Cons cljs.core/EmptyList cljs.core/List}, :doc "Marker interface indicating a persistent list", :jsdoc ("@interface")}, ArrayNodeIterator {:num-fields 3, :protocols #{cljs.core/Object}, :name cljs.core/ArrayNodeIterator, :file "cljs/core.cljs", :end-column 27, :type true, :column 10, :line 6752, :record false, :end-line 6752, :skip-protocol-flag nil}, List {:meta {:file "cljs/core.cljs", :line 1417, :column 45, :end-line 1417, :end-column 49, :declared true}, :num-fields 5, :protocols #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}, :name cljs.core/List, :file "cljs/core.cljs", :end-column 14, :type true, :column 10, :line 2879, :record false, :declared true, :end-line 2879, :skip-protocol-flag #{cljs.core/IList cljs.core/IEquiv cljs.core/IHash cljs.core/ASeq cljs.core/ICollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeq cljs.core/INext cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IStack cljs.core/ISequential cljs.core/IWithMeta cljs.core/IReduce}}, -val {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 550, :column 4, :end-line 550, :end-column 8, :protocol cljs.core/IMapEntry, :doc "Returns the value of the map entry.", :arglists (quote ([coll]))}, :protocol cljs.core/IMapEntry, :name cljs.core/-val, :variadic false, :file "cljs/core.cljs", :end-column 8, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 546, :end-line 550, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll])), :doc "Returns the value of the map entry."}, bytes {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 2660, :column 7, :end-line 2660, :end-column 12, :arglists (quote ([x]))}, :name cljs.core/bytes, :variadic false, :file "cljs/core.cljs", :end-column 12, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 2660, :end-line 2660, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ->ObjMap {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 5866, :column 10, :end-line 5866, :end-column 16, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :factory :positional, :arglists (quote ([meta keys strobj update-count __hash]))}, :protocols #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/Object cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name cljs.core/->ObjMap, :variadic false, :file "cljs/core.cljs", :end-column 16, :method-params ([meta keys strobj update-count __hash]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :factory :positional, :line 5866, :end-line 5866, :max-fixed-arity 5, :fn-var true, :arglists (quote ([meta keys strobj update-count __hash])), :skip-protocol-flag #{cljs.core/IKVReduce cljs.core/IEquiv cljs.core/IHash cljs.core/IFn cljs.core/ICollection cljs.core/IEditableCollection cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, compare-symbols {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 948, :column 8, :end-line 948, :end-column 23, :private true, :arglists (quote ([a b]))}, :private true, :name cljs.core/compare-symbols, :variadic false, :file "cljs/core.cljs", :end-column 23, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 948, :end-line 948, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, -seq {:protocol-inline nil, :meta {:file "cljs/core.cljs", :line 618, :column 16, :end-line 618, :end-column 20, :tag clj-or-nil, :protocol cljs.core/ISeqable, :doc "Returns a seq of o, or nil if o is empty.", :arglists (quote ([o]))}, :protocol cljs.core/ISeqable, :name cljs.core/-seq, :variadic false, :file "cljs/core.cljs", :end-column 20, :method-params ([o]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 616, :ret-tag clj-or-nil, :end-line 618, :max-fixed-arity 1, :tag clj-or-nil, :fn-var true, :arglists (quote ([o])), :doc "Returns a seq of o, or nil if o is empty."}}, :require-macros nil, :cljs.analyzer/constants {:seen #{form tag & stepper uuid end defrecord* base obj fqn first try has-nil? rear hierarchy iter step boolean update-count method-table chunk meta7895 i rest :meta :dup comp dispatch-fn :else left ns* :cljs.core/none shift iters xform :validator finally :default prefer-table loop* watches :ns bitmap _seq meta9608 nil-val v riter __hash meta _meta afn tree fn front buf next-entry :val key _next root-iter do vec :fallback-impl :flush-on-newline default-dispatch-val :no-test validator letfn* if arr new :descendants ns :ancestors value name :readably :more-marker fields method-cache nexts edit editable? base-count collision-hash deftype* let* start coll not-native js* strobj _rest fn* val ascending? recur ci :print-length state :ok cached-hierarchy s :parents cnt node sym sb _hash keys set! :tag tree-map . var :mutable quote root str nodes seen hash-map catch :alt-impl ext-map-iter tail record mseq count :keywordize-keys off stack meta7892 transient-map len right throw fseq meta9611 :cljs.core/not-found more def f next-iter}, :order [:flush-on-newline :readably :meta :dup :print-length :else sb :default ns name str _hash :mutable _meta val sym s value iter _rest arr i meta ci afn first rest count __hash fqn fn buf end off chunk more meta7892 meta7895 _seq _next xform iters nexts stepper state validator watches :validator edit base v start cnt shift root tail vec node fseq riter front rear keys strobj update-count record base-count fields ext-map-iter editable? len next-entry next-iter bitmap collision-hash nodes nil-val root-iter seen has-nil? :tag boolean stack ascending? key left right comp tree mseq not-native :cljs.core/not-found hash-map transient-map tree-map step :cljs.core/none :more-marker :alt-impl :fallback-impl :val f coll :keywordize-keys :parents :descendants :ancestors dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy uuid & defrecord* try ns* finally loop* do letfn* if new deftype* let* js* fn* recur set! . var quote catch throw def :ok :no-test tag form :ns obj meta9608 meta9611]}, :doc nil}